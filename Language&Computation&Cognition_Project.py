# -*- coding: utf-8 -*-
"""Language & Cognition Project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1c7NpeFKANpvCMpo1nWianG5WvCjS3TMt

# Setup

## Imports
"""

from google.colab import drive
drive.mount('/content/gdrive')
GDRIVE_DIR = '/content/gdrive/MyDrive/096222-pset-3/Structured Task (sentence decoding)'

!pip install -q transformers
!pip install -U -q sentence-transformers

import numpy as np
import torch
import sys
from sklearn.decomposition import PCA
from sklearn.decomposition import TruncatedSVD
from sklearn.feature_selection import SelectKBest,  f_regression
from transformers import AutoTokenizer, BertModel
import matplotlib.pyplot as plt
import math
import itertools
from tqdm import tqdm
import pickle
from sentence_transformers import SentenceTransformer
import warnings
from sklearn.cluster import KMeans
from sklearn.manifold import TSNE
from gensim.models import KeyedVectors
import seaborn as sns

# Download and extract the data and learn_decoder.py
!wget --load-cookies /tmp/cookies.txt "https://docs.google.com/uc?export=download&confirm=$(wget --quiet --save-cookies /tmp/cookies.txt --keep-session-cookies --no-check-certificate 'https://docs.google.com/uc?export=download&id=1xZaorRH-xxjfochvSesAhOTUg82_Xq56' -O- | sed -rn 's/.*confirm=([0-9A-Za-z_]+).*/\1\n/p')&id=1xZaorRH-xxjfochvSesAhOTUg82_Xq56" -O files.zip && rm -rf /tmp/cookies.txt
!unzip files.zip
!rm files.zip

#Let's load the functions from learn_decoder.py
from learn_decoder import *

!time wget https://huggingface.co/stanfordnlp/glove/resolve/main/glove.42B.300d.zip
!unzip glove.42B.300d.zip

"""## Utility Functions"""

def get_glove_embeddings(word_list):
  embeddings = []
  for word in word_list:
    embeddings.append(all_embeddings[word])
  return np.array(embeddings)

def cosine_similarity(x: np.ndarray, y: np.ndarray) -> float:
    common_dtype = np.float64  # Choose the desired common data type
    x = x.astype(common_dtype)
    y = y.astype(common_dtype)
    dot_product = np.dot (x,y)
    x_norm = np.linalg.norm(x)
    y_norm = np.linalg.norm(y)

    return dot_product/ (x_norm* y_norm)

#calculate the rank of the true vector based on cosine similarity
def rank_based_accuracy (decoded_vec, true_vec, vectors):
  rank= {}
  true_vec_index = -1

  for i in range(vectors.shape[0]):
    rank[i]= cosine_similarity(vectors[i], decoded_vec)
    if np.array_equal(true_vec, vectors[i]):
      true_vec_index=i

  rankings = dict(sorted(rank.items(), key=lambda item: item[1], reverse= True))
  final_rank = list(rankings).index(true_vec_index)
  return final_rank + 1

def calculate_rank(decoder_res, test_set, test_vectors, index, vectors, all_ranks, avg_ranking, concepts=0, semi=False):
  increments = 12 if semi else 10
  key= (index/increments)+1
  test_fold_ranking= []
  for i in np.arange(test_set.shape[0]):
    dot_prod = np.dot(test_set[i],decoder_res) #semantic vector - the model's best guess to the concept
    current_rank= rank_based_accuracy(dot_prod, test_vectors[i], vectors) #rank of the current test data
    test_fold_ranking.append(current_rank)
    if semi:
      all_ranks[index]= current_rank
    else:
      all_ranks[concepts[index]]= current_rank

    index= index+1

  avg_ranking[key]= round(sum(test_fold_ranking)/len(test_fold_ranking), 2)
  return all_ranks, avg_ranking

def calculate_rank_sentences(decoder_res, test_set, vectors, concepts):
    avg_ranking = {}
    all_ranks = {}
    test_fold_ranking= []
    for i in np.arange(test_set.shape[0]):
      dot_prod = np.dot(test_set[i],decoder_res) #semantic vector - the model's best guess to the concept
      current_rank= rank_based_accuracy(dot_prod, vectors[i], vectors) #rank of the current test data
      test_fold_ranking.append(current_rank)
      all_ranks[i] = current_rank

    #avg_ranking[i]= sum(test_fold_ranking)/len(test_fold_ranking)
    return all_ranks

def train_decoder(data, vectors, concepts=0, semi = False):
  all_ranks = {} #rank of each concept
  avg_ranking = {} #avg rank of each fold
  increments = 12 if semi else 10
  for i in np.arange(0, data.shape[0], increments):
    temp_test_set = data[i:i+increments]
    temp_test_vectors = vectors[i:i+increments]
    temp_train_set = np.concatenate((data[0:i], data[i+increments: data.shape[0]]))
    temp_train_vectors = np.concatenate((vectors[0:i], vectors[i+increments: data.shape[0]]))

    decoder_res = learn_decoder(temp_train_set, temp_train_vectors) #decoder matrix

    calculate_rank(decoder_res, temp_test_set, temp_test_vectors, i, vectors, all_ranks, avg_ranking, concepts, semi) #calculate rank for each concept and for each fold

    print(f'Average Score of Fold {(i/increments)+1} is: {avg_ranking[(i/increments)+1]}')

  return all_ranks, avg_ranking

def pca_cumulative_var(name , data, threshold, cv=False):
  pca = PCA(n_components=data.shape[0])
  pca.fit(data)

  # Calculate cumulative explained variance
  cumulative_variance = np.cumsum(pca.explained_variance_ratio_)
  explained_var = threshold
  index= np.abs(cumulative_variance - explained_var).argmin()
  print(f'The number of components that explain {threshold*100} % of the {name}variance is {index}')
  # Plot cumulative explained variance
  if not cv:
    plt.plot(range(1, len(cumulative_variance) + 1), cumulative_variance)
    plt.xlabel('Number of Components')
    plt.ylabel('Cumulative Explained Variance')
    plt.axhline(y = explained_var, color ="red", linestyle ="--")
    plt.axvline(x=index, color='red', linestyle='--')
    plt.suptitle(name + "Explained Variance per Number of Components")
    plt.show()
  return index

def plot_concepts(concepts, type, description, exp):
  top_15 = dict(itertools.islice(concepts.items(), 15))
  x_axis =top_15.keys()
  y_axis = top_15.values()
  plt.figure(figsize=(10,6))
  plt.bar(x_axis, y_axis)
  x_tick = plt.xticks(rotation = 60)
  plt.title("Top 15 " +type+ description+ exp)
  plt.xlabel("Concept")
  plt.ylabel("Accuracy Score")
  plt.plot()

def plot_fold_avg_acc(num_folds,avg_ranking):
  x_axis =np.arange(1,num_folds+1)
  y_axis = avg_ranking.values()
  plt.bar(x_axis, y_axis)
  x_tick = plt.xticks(range(min(x_axis), max(x_axis)+1))
  plt.title("Accuracy Score per Fold")
  plt.xlabel("Number of Fold")
  plt.ylabel("Avg Accuracy Score")

def successful_failed_concepts(concepts,all_ranks):
  successful_concepts = {}
  failed_concepts = {}

  for concept in concepts:
    if all_ranks[concept]<90:
      successful_concepts[concept]= all_ranks[concept]
    else:
      failed_concepts[concept]= all_ranks[concept]

  successful_concepts = dict(sorted(successful_concepts.items(), key=lambda item: item[1]))
  failed_concepts = dict(sorted(failed_concepts.items(), key=lambda item: item[1] ,  reverse= True))

  print(f'Successful Concepts Are : {successful_concepts}')
  print(f'Number of Succesful Concepts: {len(successful_concepts)}')
  print(f'Average Rank of Succesful Concepts: {sum(successful_concepts.values()) / len(successful_concepts)}')
  print()
  print(f'Failed Concepts Are : {failed_concepts}')
  print(f'Number of Failed Concepts: {len(failed_concepts)}')
  print(f'Average Rank of Failed Concepts: {sum(failed_concepts.values()) / len(failed_concepts)}')

  return successful_concepts, failed_concepts

def open_pkl(path):
  with open(path , 'rb') as f:
    data = pickle.load(f)

  return data

def read_txt(path):
  data_list = []
  with open(path, 'r') as file:
      for line in file:
          line_data = line.strip().rstrip('.')  # remove dots at the end of the line
          line_data = line_data.strip().lower()  # convert the line to lowercase
          line_data = line_data.split()  # split the line by whitespace
          data_list.append(line_data)

  # convert the list into a NumPy array
  data_array = np.array(data_list)
  return data_array

def find_key_passage(data, index):
  sentence_passage_id = data['labelsPassageForEachSentence'][index][0]
  sentence_key_passage = data['keyPassages'][sentence_passage_id-1][0][0]
  indices = np.where(data['keyPassages'] == sentence_key_passage)[0]
  passage_category_index_sentence = data['labelsPassageCategory'][indices][0][0]
  key_passage_category_sentence = data['keyPassageCategory'][0][passage_category_index_sentence-1][0]

  return key_passage_category_sentence

def get_key_passage_dict (data):
  passage_dict={}

  for i in data:
    word= i[0]
    passage_dict[word]=0

  return passage_dict

def successful_failed_topics(data, ranks):

  key_passage_dict= get_key_passage_dict(data['keyPassageCategory'][0])
  key_count = get_key_passage_dict(data['keyPassageCategory'][0])

  successful_topics={}
  failed_topics={}

  length = len(ranks)
  for i in range(length-1):
    key = find_key_passage(data,i)
    rank= ranks[i]
    key_passage_dict[key] +=rank
    key_count[key] +=1

  for key in key_passage_dict:
    key_passage_dict[key]= round(key_passage_dict[key]/key_count[key],3)

    if key_passage_dict[key] < length/2:
      successful_topics[key]= key_passage_dict[key]

    else:
      failed_topics[key]= key_passage_dict[key]

  successful_topics = dict(sorted(successful_topics.items(), key=lambda item: item[1]))
  failed_topics = dict(sorted(failed_topics.items(), key=lambda item: item[1] ,  reverse= True))

  print(f'Successful Key Passages are : {successful_topics}')
  print(f'Number of Succesful Key Passages: {len(successful_topics)}')
  print(f'Average Rank of Succesful Topics: {sum(successful_topics.values()) / len(successful_topics)}')
  print()
  print(f'Failed Key Passages are : {failed_topics}')
  print(f'Number of Failed Key Passages: {len(failed_topics)}')
  if len(failed_topics) != 0:
    print(f'Average Rank of Failed Topics: {sum(failed_topics.values()) / len(failed_topics)}')

  return successful_topics, failed_topics

"""## Load Data"""

data = read_matrix("imaging_data.csv", sep=",")
vectors = read_matrix("vectors_180concepts.GV42B300.txt", sep=" ")
concepts = np.genfromtxt('stimuli_180concepts.txt', dtype=np.dtype('U')) #The names of the 180 concepts

#exp2
data_exp2_path= 'gdrive/MyDrive/Structured_Task/EXP2.pkl'
concepts_exp2_path = 'gdrive/MyDrive/Structured_Task/stimuli_384sentences.txt'
vectors_exp2_path = 'gdrive/MyDrive/Structured_Task/vectors_384sentences.GV42B300.average.txt'

data_exp2= (open_pkl(data_exp2_path))
concepts_exp2= (read_txt(concepts_exp2_path))
vectors_exp2 = (read_txt(vectors_exp2_path))

#exp3
data_exp3_path= 'gdrive/MyDrive/Structured_Task/EXP3.pkl'
concepts_exp3_path='gdrive/MyDrive/Structured_Task/stimuli_243sentences.txt'
vectors_exp3_path = 'gdrive/MyDrive/Structured_Task/vectors_243sentences.GV42B300.average.txt'

data_exp3= (open_pkl(data_exp3_path))
concepts_exp3= (read_txt(concepts_exp3_path))
vectors_exp3= (read_txt(vectors_exp3_path))

fmri_exp2 = data_exp2['Fmridata']
fmri_exp3 = data_exp3['Fmridata']

data_file_path = 'gdrive/MyDrive/Structured_Task/neuralData_for_EXP1.csv'
data_c = np.genfromtxt(data_file_path, delimiter=',')
data_c = data_c[1:, 1:] #remove the first row and column

sentences_exp2 = []
for sentence in data_exp2['keySentences']:
  sentences_exp2.append(sentence[0][0].lower().rstrip('.'))

model = SentenceTransformer('paraphrase-MiniLM-l6-v2')
sentences_exp2_bert = model.encode(sentences_exp2)

tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased")
model = BertModel.from_pretrained("bert-base-uncased")

inputs = tokenizer(list(concepts), return_tensors="pt", padding=True)
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state
vectors_bert = last_hidden_states[:,1,:].detach().numpy()

all_embeddings = {}
with open("/content/glove.42B.300d.txt", 'rt') as infile:
    for line in infile:
        word, *rest = line.split()
        all_embeddings[word] = np.array(list(map(float, rest)))

"""# Part 1 - Structured Tasks

## Section A

> Repeating Homework 3 Question 3 with BERT embeddings instead of GloVe.

Comparing Different cumulative variance thresholds and BERT's performance to obtain the best PCA threshold. Note that we are taking the maximum number of compnents between the BERT vectors and fMRI vectors to ensure the cumulative variance level is always met.
"""

thresholds = [0.7, 0.75, 0.8, 0.85, 0.9, 0.95]
all_ranks_thresholds= {}
avg_ranks_thresholds={}
successful_concepts_bert={}
failed_concepts_bert={}
for threshold in thresholds:
  print(f'--------------------------- Threshold: {threshold} -----------------------------------------')
  n_components_bert = pca_cumulative_var("Bert Vectors ", vectors_bert, threshold, cv=True)
  n_components_data = pca_cumulative_var("fMRI Data ", data, threshold, cv=True)
  pca = PCA(n_components=max(n_components_bert, n_components_data), svd_solver = 'full')
  pca.fit(vectors_bert)
  vectors_pca = pca.transform(vectors_bert)
  pca.fit(data)
  data_pca = pca.transform(data)
  all_ranks_thresholds[threshold], avg_ranks_thresholds[threshold] = train_decoder(data_pca, vectors_pca, concepts)
  successful_concepts_bert[threshold], failed_concepts_bert[threshold]= successful_failed_concepts(concepts,all_ranks_thresholds[threshold])

"""We find that taking the components that explain 85-90% of the variance give the best results. We'll use 85% because it had a better accuracy score for the successful concepts."""

n_components_bert = pca_cumulative_var("Bert Vectors ", vectors_bert, 0.85)

n_components_data = pca_cumulative_var("Data ", data, 0.85)

"""Now let's plot the averaged accuracy score for each fold"""

plot_fold_avg_acc(18,avg_ranks_thresholds[0.85])

"""We'll consider a "successful concept"  as a concept with an average rank lower than 90, as a score of 90 represents random noise."""

plot_concepts(successful_concepts_bert[0.85], "Successful ", "Concepts", "")

plot_concepts(failed_concepts_bert[0.85], "Failed ","Concepts", "")

"""**Let's get a reminder of the outcome from HW3 with the GloVe embeddings. **
Note that GloVe succeeded in 134 concepts and failed in 46.


![glove1hw3forcomparison.png](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAjsAAAHHCAYAAABZbpmkAAAAOXRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjcuMSwgaHR0cHM6Ly9tYXRwbG90bGliLm9yZy/bCgiHAAAACXBIWXMAAA9hAAAPYQGoP6dpAABHIklEQVR4nO3deViU9f7/8dfIHgKubC6AK+Zaaq5pKoG7puVyNCU7ZoUpWpaeckktxJPmmraoaaF27KjH7KjHLc0yF0zNMjLTXHFJAZdEgfv3Rz/n6wQuAzeCd8/Hdd3X1Xzuez7v90yCLz9z33PbDMMwBAAAYFFFCroBAACA/ETYAQAAlkbYAQAAlkbYAQAAlkbYAQAAlkbYAQAAlkbYAQAAlkbYAQAAlkbYAQAAlkbYAQDkSnR0tEJDQ2973OHDh2Wz2fThhx/me09ATgg7wF3wzjvvyGazqUGDBgXdyj3n8OHDeuqpp1SxYkV5enoqMDBQzZo10+jRowu6tXtSdHS0bDZbjtvq1asLuj0gX7gWdAPAX0FCQoJCQ0O1fft2/fzzz6pUqVJBt3RP+Pnnn1W/fn15eXmpX79+Cg0N1cmTJ7Vr1y7Fx8fr9ddfL+gW70keHh764IMPso3Xrl27ALoB8h9hB8hnhw4d0tdff62lS5dqwIABSkhIKLSrEpcuXZK3t3dBt2H39ttv6+LFi9q9e7dCQkIc9p0+ffqu9lLY3pubMQxDV65ckZeX102PcXV1Ve/eve9iV0DB4mMsIJ8lJCSoePHiateunR5//HElJCTkeFxKSoqGDBmi0NBQeXh4qGzZsurTp4/Onj1rP+bKlSsaM2aMqlSpIk9PTwUFBalLly46ePCgJOmLL76QzWbTF1984TB3TudMREdHq2jRojp48KDatm0rHx8f9erVS5L05Zdf6oknnlD58uXl4eGhcuXKaciQIfr999+z9f3jjz+qW7duKl26tLy8vFS1alW9+uqrkqSNGzfKZrNp2bJl2Z63cOFC2Ww2bd269abv3cGDB1W2bNlsQUeS/P39s42tWrVKzZs3l4+Pj3x9fVW/fn0tXLjQ4ZglS5aobt268vLyUqlSpdS7d28dP37c4ZhbvTdZWVmaMmWKqlevLk9PTwUEBGjAgAE6f/78TV/Hn+f95ZdfFBUVJW9vbwUHB2vs2LEyDMPh2DutExoaqvbt22vNmjWqV6+evLy89O677962l9t55513VL16dXl4eCg4OFgxMTFKSUm57fNSUlIUHR0tPz8/FStWTH379r2j5wH5ibAD5LOEhAR16dJF7u7u6tmzpw4cOKAdO3Y4HHPx4kU9/PDDmj59uiIjIzV16lQ9++yz+vHHH3Xs2DFJUmZmptq3b6/XX39ddevW1aRJkzR48GClpqZq3759ueotIyNDUVFR8vf311tvvaWuXbtK+iMQXL58Wc8995ymT5+uqKgoTZ8+XX369HF4/t69e9WgQQNt2LBB/fv319SpU9W5c2d99tlnkqRHHnlE5cqVyzHgJSQkqGLFimrUqNFN+wsJCdHRo0e1YcOG276WDz/8UO3atdO5c+c0YsQITZgwQXXq1HE4D+XDDz9Ut27d5OLiori4OPXv319Lly5V06ZNs/2FfLP3ZsCAARo2bJiaNGmiqVOn6qmnnlJCQoKioqJ07dq12/aZmZmp1q1bKyAgQBMnTlTdunU1evTobKt9ztRJSkpSz5499eijj2rq1KmqU6fObfs4e/asw5aammrfN2bMGMXExCg4OFiTJk1S165d9e677yoyMvKWr9EwDHXq1EkfffSRevfurfHjx+vYsWPq27fvbfsB8pUBIN/s3LnTkGSsXbvWMAzDyMrKMsqWLWsMHjzY4bhRo0YZkoylS5dmmyMrK8swDMOYO3euIcmYPHnyTY/ZuHGjIcnYuHGjw/5Dhw4Zkox58+bZx/r27WtIMoYPH55tvsuXL2cbi4uLM2w2m/Hrr7/ax5o1a2b4+Pg4jN3Yj2EYxogRIwwPDw8jJSXFPnb69GnD1dXVGD16dLY6N9q3b5/h5eVlSDLq1KljDB482Fi+fLlx6dIlh+NSUlIMHx8fo0GDBsbvv/+eYy9Xr141/P39jRo1ajgcs3LlSkOSMWrUKPvYzd6bL7/80pBkJCQkOIyvXr06x/E/uz7vCy+84NBfu3btDHd3d+PMmTNO1wkJCTEkGatXr75l7T/38OetefPmhmH88f/G3d3diIyMNDIzM+3PmzFjhiHJmDt3rsNcISEh9sfLly83JBkTJ060j2VkZBgPP/xwtj9/wN3Eyg6QjxISEhQQEKAWLVpIkmw2m7p3767FixcrMzPTfty///1v1a5dW4899li2OWw2m/2YUqVK6YUXXrjpMbnx3HPPZRu78XyPS5cu6ezZs2rcuLEMw9C3334rSTpz5ow2b96sfv36qXz58jftp0+fPkpPT9enn35qH/vkk0+UkZFx2/NGqlevrt27d6t37946fPiwfeUoICBA77//vv24tWvX6sKFCxo+fLg8PT1z7GXnzp06ffq0nn/+eYdj2rVrp/DwcH3++ee3fW+WLFkiPz8/Pfroow6rInXr1lXRokW1cePGW76e6wYOHOjQ38CBA3X16lWtW7cuV3XCwsIUFRV1R7UlydPTU2vXrnXYJk2aJElat26drl69qtjYWBUp8n9/RfTv31++vr45vk/X/fe//5Wrq6vD++bi4pLjn1ngbuIEZSCfZGZmavHixWrRooUOHTpkH2/QoIEmTZqk9evXKzIyUtIf56Zc/5jkZg4ePKiqVavK1dW8H1tXV1eVLVs22/iRI0c0atQorVixIts5Itc/7vjll18kSTVq1LhljfDwcNWvX18JCQl6+umnJf0RAhs2bHhHV6VVqVJFH330kTIzM/XDDz9o5cqVmjhxop555hmFhYUpIiLCfs7SrXr59ddfJUlVq1bNscctW7Y4jOX03hw4cECpqak5ni8k3dlJ00WKFFGFChWyvUbpj3OrclMnLCzstnVv5OLiooiIiBz33ex9cnd3V4UKFez7b/bcoKAgFS1a1GE8p/ccuJsIO0A+2bBhg06ePKnFixdr8eLF2fYnJCTYw45ZbrbCc+Mq0o08PDwc/vV+/dhHH31U586d0yuvvKLw8HB5e3vr+PHjio6OVlZWltN99enTR4MHD9axY8eUnp6ub775RjNmzHBqDhcXF9WsWVM1a9ZUo0aN1KJFCyUkJNz0L+28yum9ycrKkr+//01PMi9durQptZ2tc6srrwAQdoB8k5CQIH9/f82cOTPbvqVLl2rZsmWaPXu2vLy8VLFixdueZFyxYkVt27ZN165dk5ubW47HFC9eXJKynWx7q3+N/9l3332nn376SfPnz3c4IXnt2rUOx11fnbiTk6N79OihoUOHatGiRfr999/l5uam7t2733FPf1avXj1J0smTJyX98d5c7+Vmq0XXr+hKSkpSy5YtHfYlJSXleMXXn1WsWFHr1q1TkyZNch0wsrKy9Msvv9hXcyTpp59+kiT7txGbUSe3bnyfblyBunr1qg4dOnTLcBkSEqL169fr4sWLDqs7SUlJ+dcwcAc4ZwfIB7///ruWLl2q9u3b6/HHH8+2DRw4UBcuXNCKFSskSV27dtWePXtyvETb+P+XJHft2lVnz57NcUXk+jEhISFycXHR5s2bHfa/8847d9y7i4uLw5zX/3vq1KkOx5UuXVrNmjXT3LlzdeTIkRz7ua5UqVJq06aNPv74YyUkJKh169YqVarUbXv58ssvc7z657///a+k//t4JDIyUj4+PoqLi9OVK1dy7KVevXry9/fX7NmzlZ6ebt+/atUq7d+/X+3atbttP926dVNmZqbGjRuXbV9GRsYdX2J94/9DwzA0Y8YMubm5qVWrVqbWyY2IiAi5u7tr2rRpDv8f58yZo9TU1Fu+T23btlVGRoZmzZplH8vMzNT06dPzrV/gTrCyA+SDFStW6MKFC+rYsWOO+xs2bKjSpUsrISFB3bt317Bhw/Tpp5/qiSeeUL9+/VS3bl2dO3dOK1as0OzZs1W7dm316dNHCxYs0NChQ7V9+3Y9/PDDunTpktatW6fnn39enTp1kp+fn5544glNnz5dNptNFStW1MqVK536Ar7w8HBVrFhRL730ko4fPy5fX1/9+9//zvF7ZKZNm6amTZvqwQcftJ9Dc/jwYX3++efavXu3w7F9+vTR448/Lkk5/iWek/j4eCUmJqpLly6qVauWJGnXrl1asGCBSpQoodjYWEmSr6+v3n77bf39739X/fr19be//U3FixfXnj17dPnyZc2fP19ubm6Kj4/XU089pebNm6tnz546deqUpk6dqtDQUA0ZMuS2/TRv3lwDBgxQXFycdu/ercjISLm5uenAgQNasmSJpk6dan+NN+Pp6anVq1erb9++atCggVatWqXPP/9c//jHP+wfT5lRJ7dKly6tESNG6PXXX1fr1q3VsWNHJSUl6Z133lH9+vVveVJ5hw4d1KRJEw0fPlyHDx/W/fffr6VLlzpc1g4UiAK7DgywsA4dOhienp7ZLpG+UXR0tOHm5macPXvWMAzD+O2334yBAwcaZcqUMdzd3Y2yZcsaffv2te83jD8uCX/11VeNsLAww83NzQgMDDQef/xx4+DBg/Zjzpw5Y3Tt2tW47777jOLFixsDBgww9u3bl+Ol597e3jn29sMPPxgRERFG0aJFjVKlShn9+/c39uzZk+Plw/v27TMee+wxo1ixYoanp6dRtWpVY+TIkdnmTE9PN4oXL274+flluzz8Zr766isjJibGqFGjhuHn52e4ubkZ5cuXN6Kjox1e83UrVqwwGjdubHh5eRm+vr7GQw89ZCxatMjhmE8++cR44IEHDA8PD6NEiRJGr169jGPHjjkcc6v3xjAM47333jPq1q1reHl5GT4+PkbNmjWNl19+2Thx4sQtX8/1eQ8ePGhERkYa9913nxEQEGCMHj3a4TJvZ+qEhIQY7dq1u2VdZ17bdTNmzDDCw8MNNzc3IyAgwHjuueeM8+fPZ5vrxkvPDeOPP8dPPvmk4evra/j5+RlPPvmk8e2333LpOQqUzTD+tN4MAPkgIyNDwcHB6tChg+bMmVPQ7RSI6Ohoffrpp7p48WJBtwL8pXDODoC7Yvny5Tpz5ky2b2EGgPzGOTsA8tW2bdu0d+9ejRs3Tg888ICaN29e0C0B+IthZQdAvpo1a5aee+45+fv7a8GCBQXdDoC/IM7ZAQAAlsbKDgAAsDTCDgAAsDROUNYfX99+4sQJ+fj45Onu0QAA4O4xDEMXLlxQcHBwtnvZ3YiwI+nEiRMqV65cQbcBAABy4ejRoypbtuxN9xN2JPn4+Ej6483y9fUt4G4AAMCdSEtLU7ly5ex/j98MYUeyf3Tl6+tL2AEA4B5zu1NQOEEZAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYGmEHAABYmmtBNwAAkhQ6/HNT5zs8oZ2p8wG4d7GyAwAALI2wAwAALI2wAwAALI2wAwAALI2wAwAALI2wAwAALI2wAwAALI2wAwAALI2wAwAALI2wAwAALI2wAwAALI2wAwAALK1Aw87mzZvVoUMHBQcHy2azafny5Q77DcPQqFGjFBQUJC8vL0VEROjAgQMOx5w7d069evWSr6+vihUrpqeffloXL168i68CAAAUZgUadi5duqTatWtr5syZOe6fOHGipk2bptmzZ2vbtm3y9vZWVFSUrly5Yj+mV69e+v7777V27VqtXLlSmzdv1jPPPHO3XgIAACjkXAuyeJs2bdSmTZsc9xmGoSlTpui1115Tp06dJEkLFixQQECAli9frh49emj//v1avXq1duzYoXr16kmSpk+frrZt2+qtt95ScHDwXXstAACgcCq05+wcOnRIycnJioiIsI/5+fmpQYMG2rp1qyRp69atKlasmD3oSFJERISKFCmibdu23XTu9PR0paWlOWwAAMCaCm3YSU5OliQFBAQ4jAcEBNj3JScny9/f32G/q6urSpQoYT8mJ3FxcfLz87Nv5cqVM7l7AABQWBTasJOfRowYodTUVPt29OjRgm4JAADkk0IbdgIDAyVJp06dchg/deqUfV9gYKBOnz7tsD8jI0Pnzp2zH5MTDw8P+fr6OmwAAMCaCm3YCQsLU2BgoNavX28fS0tL07Zt29SoUSNJUqNGjZSSkqLExET7MRs2bFBWVpYaNGhw13sGAACFT4FejXXx4kX9/PPP9seHDh3S7t27VaJECZUvX16xsbEaP368KleurLCwMI0cOVLBwcHq3LmzJKlatWpq3bq1+vfvr9mzZ+vatWsaOHCgevTowZVYAABAUgGHnZ07d6pFixb2x0OHDpUk9e3bVx9++KFefvllXbp0Sc8884xSUlLUtGlTrV69Wp6envbnJCQkaODAgWrVqpWKFCmirl27atq0aXf9tQAAgMLJZhiGUdBNFLS0tDT5+fkpNTWV83eAAhI6/HNT5zs8oZ2p8wEofO707+9Ce84OAACAGQg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0gg7AADA0lwLugEAAFC4hA7/3NT5Dk9oZ+p8zmJlBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWBphBwAAWJprQTdwK5mZmRozZow+/vhjJScnKzg4WNHR0Xrttddks9kkSYZhaPTo0Xr//feVkpKiJk2aaNasWapcuXIBd4/CLHT456bOd3hCO1PnAwCYp1Cv7MTHx2vWrFmaMWOG9u/fr/j4eE2cOFHTp0+3HzNx4kRNmzZNs2fP1rZt2+Tt7a2oqChduXKlADsHAACFRaFe2fn666/VqVMntWv3x7+aQ0NDtWjRIm3fvl3SH6s6U6ZM0WuvvaZOnTpJkhYsWKCAgAAtX75cPXr0KLDeAQBA4VCoV3YaN26s9evX66effpIk7dmzR1u2bFGbNm0kSYcOHVJycrIiIiLsz/Hz81ODBg20devWAukZAAAULoV6ZWf48OFKS0tTeHi4XFxclJmZqTfeeEO9evWSJCUnJ0uSAgICHJ4XEBBg35eT9PR0paen2x+npaXlQ/cAAKAwKNQrO//617+UkJCghQsXateuXZo/f77eeustzZ8/P0/zxsXFyc/Pz76VK1fOpI4BAEBhU6jDzrBhwzR8+HD16NFDNWvW1JNPPqkhQ4YoLi5OkhQYGChJOnXqlMPzTp06Zd+XkxEjRig1NdW+HT16NP9eBAAAKFCFOuxcvnxZRYo4tuji4qKsrCxJUlhYmAIDA7V+/Xr7/rS0NG3btk2NGjW66bweHh7y9fV12AAAgDUV6nN2OnTooDfeeEPly5dX9erV9e2332ry5Mnq16+fJMlmsyk2Nlbjx49X5cqVFRYWppEjRyo4OFidO3cu2OYBAEChUKjDzvTp0zVy5Eg9//zzOn36tIKDgzVgwACNGjXKfszLL7+sS5cu6ZlnnlFKSoqaNm2q1atXy9PTswA7BwAAhUWhDjs+Pj6aMmWKpkyZctNjbDabxo4dq7Fjx969xgAAwD2jUJ+zAwAAkFeEHQAAYGmEHQAAYGmEHQAAYGmF+gRlALcWOvxzU+c7PKGdqfMBQGHAyg4AALA0wg4AALA0wg4AALA0wg4AALA0wg4AALC0XIedn3/+WWvWrNHvv/8uSTIMw7SmAAAAzOJ02Pntt98UERGhKlWqqG3btjp58qQk6emnn9aLL75oeoMAAAB54fT37AwZMkSurq46cuSIqlWrZh/v3r27hg4dqkmTJpnaIHCv4jtwAKBwcDrs/O9//9OaNWtUtmxZh/HKlSvr119/Na0xAAAAMzj9MdalS5d03333ZRs/d+6cPDw8TGkKAADALE6HnYcfflgLFiywP7bZbMrKytLEiRPVokULU5sDAADIK6c/xpo4caJatWqlnTt36urVq3r55Zf1/fff69y5c/rqq6/yo0cAAIBcc3plp0aNGvrpp5/UtGlTderUSZcuXVKXLl307bffqmLFivnRIwAAQK45tbJz7do1tW7dWrNnz9arr76aXz0BAACYxqmVHTc3N+3duze/egEAADCd0x9j9e7dW3PmzMmPXgAAAEzn9AnKGRkZmjt3rtatW6e6devK29vbYf/kyZNNaw4AACCvnA47+/bt04MPPihJ+umnnxz22Ww2c7oCAAAwidNhZ+PGjfnRBwAAQL7I9V3PJenYsWM6duyYWb0AAACYzumVnaysLI0fP16TJk3SxYsXJUk+Pj568cUX9eqrr6pIkTzlJ/zFcfNMAIDZnA47r776qubMmaMJEyaoSZMmkqQtW7ZozJgxunLlit544w3TmwQAAMgtp8PO/Pnz9cEHH6hjx472sVq1aqlMmTJ6/vnnCTsAAKBQcfozp3Pnzik8PDzbeHh4uM6dO2dKUwAAAGZxOuzUrl1bM2bMyDY+Y8YM1a5d25SmAAAAzJKru563a9dO69atU6NGjSRJW7du1dGjR/Xf//7X9AYBAADywumVnebNmyspKUmPPfaYUlJSlJKSoi5duigpKUkPP/xwfvQIAACQa06v7EhSmTJlOBEZAADcE5xe2Zk3b56WLFmSbXzJkiWaP3++KU0BAACYxemwExcXp1KlSmUb9/f315tvvmlKUwAAAGZxOuwcOXJEYWFh2cZDQkJ05MgRU5oCAAAwi9Nhx9/fX3v37s02vmfPHpUsWdKUpgAAAMzidNjp2bOnBg0apI0bNyozM1OZmZnasGGDBg8erB49euRHjwAAALnm9NVY48aN0+HDh9WqVSu5uv7x9KysLPXp04dzdnLAjS0BAChYTocdd3d3ffLJJxo/frx2794tLy8v1axZUyEhIfnRHwAAQJ7k6nt2JKly5cqqXLmyMjIydOXKFTN7AgAAMM0dh53PPvtMv/32m6Kjo+1jb7zxhsaNG6eMjAy1bNlSn3zyiYoXL54ffQIALIqP+5Hf7jjsTJ48WY8//rj98ddff61Ro0Zp7Nixqlatml599VWNGzdOkydPzpdGAeBewV/eQOFyx1djff/992rcuLH98aeffqpHH31Ur776qrp06aJJkybps88+y5cmAQAAcuuOw86FCxccvkdny5YtatWqlf1x9erVdeLECXO7AwAAyKM7DjtlypTR/v37JUkXL17Unj17HFZ6fvvtN913333mdwgAAJAHdxx2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9lvNmTNH7733njZt2qRNmzbp/fff15w5c7R+/XoNHTpUlSpV0g8//GB6sxMmTJDNZlNsbKx97MqVK4qJiVHJkiVVtGhRde3aVadOnTK9NgAAuDc5HXY6deqkiIgInThxQomJiUpMTNSxY8f06KOPqmfPnjp+/LiaNWumIUOGmNrojh079O6776pWrVoO40OGDNFnn32mJUuWaNOmTTpx4oS6dOliam0AAHDvcjrs/POf/9S4cePk6+trH/Pz89OYMWM0ceJE3XfffRo1apQSExNNa/LixYvq1auX3n//ffvd1iUpNTVVc+bM0eTJk9WyZUvVrVtX8+bN09dff61vvvnGtPoAAODe5XTYSU1N1enTp7ONnzlzRmlpaZKkYsWK6erVq3nv7v+LiYlRu3btFBER4TCemJioa9euOYyHh4erfPny2rp1q2n1AQDAvcvpE5Q7deqkfv36adKkSapfv76kPz5ieumll9S5c2dJ0vbt21WlShVTGly8eLF27dqlHTt2ZNuXnJwsd3d3FStWzGE8ICBAycnJN50zPT1d6enp9sfXQxoAALAep8POu+++qyFDhqhHjx7KyMj4YxJXV/Xt21dvv/22pD9WVz744IM8N3f06FENHjxYa9eulaenZ57nuy4uLk6vv/66afMBAIDCy+mwU7RoUb3//vt6++239csvv0iSKlSooKJFi9qPqVOnjinNJSYm6vTp03rwwQftY5mZmdq8ebNmzJihNWvW6OrVq0pJSXFY3Tl16pQCAwNvOu+IESMcLqFPS0tTuXLlTOkZAID8xGX0znM67Hz88cfq0qWLihYtmu3KKLO1atVK3333ncPYU089pfDwcL3yyisqV66c3NzctH79enXt2lWSlJSUpCNHjqhRo0Y3ndfDw0MeHh752jsAACgcnA47Q4YM0bPPPquOHTuqd+/eioqKkouLS370Jh8fH9WoUcNhzNvbWyVLlrSPP/300xo6dKhKlCghX19fvfDCC2rUqJEaNmyYLz0BuHfxL2Lgr8npq7FOnjypxYsXy2azqVu3bgoKClJMTIy+/vrr/Ojvtt5++221b99eXbt2VbNmzRQYGKilS5cWSC8AAKDwcXplx9XVVe3bt1f79u11+fJlLVu2TAsXLlSLFi1UtmxZHTx4MD/6tPviiy8cHnt6emrmzJmaOXNmvtYFAAD3JqfDzo3u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Qwf99ttvkqSUlBS1bNlSDzzwgHbu3KnVq1fr1KlT6tatm8Mc8+fPl7u7u7766ivNnj07x/6mTp2qSZMm6a233tLevXsVFRWljh076sCBA5KkkydPqnr16nrxxRd18uRJvfTSS06/B8ePH1fbtm1Vv3597dmzR7NmzdKcOXM0fvz4mz4nOjpaR48e1caNG/Xpp5/qnXfe0enTp52uDUDc9RyAo759+xqdOnUyDMMwGjZsaPTr188wDMNYtmyZceOvjNGjRxu1a9d2eO7bb79thISEOMwVEhJiZGZm2seqVq1qPPzww/bHGRkZhre3t7Fo0SLDMAz7XbonTJhgP+batWtG2bJljfj4eMMwDGPcuHFGZGSkQ+2jR4863OG9efPmxgMPPHDb1xscHGy88cYbDmP169c3nn/+efvj2rVr3/ZO5H379jVcXFwMb29v+/b4448bhmEY//jHP4yqVas63AV65syZRtGiRe3vTfPmzY3BgwcbhmEYSUlJhiSHu4bv37/fkJSru3wDf3WuBZq0ABRq8fHxatmyZa5WM66rXr26ihT5v0XkgIAA1ahRw/7YxcVFJUuWzLZq0ahRI/t/u7q6ql69etq/f78kac+ePdq4caOKFi2ard7BgwdVpUoVSVLdunVv2VtaWppOnDihJk2aOIw3adJEe/bsucNX+H9atGihWbNm2R97e3tLkvbv369GjRo5nODdpEkTXbx4UceOHVP58uUd5tm/f79cXV0d+g8PD1exYsWc7gmARNgBcFPNmjVTVFSURowYoejoaId9RYoUkWEYDmPXrl3LNoebm5vDY5vNluNYVlbWHfd18eJFdejQQfHx8dn2BQUF2f/7eti4W7y9vVWpUqW7WhPA7XHODoBbmjBhgj777DNt3brVYbx06dJKTk52CDxmfjfON998Y//vjIwMJSYmqlq1apKkBx98UN9//71CQ0NVqVIlh82ZgOPr66vg4GB99dVXDuNfffWV7r//fnNeiKRq1app69atDu/VV199JR8fH5UtWzbb8eHh4fbXfF1SUpJSUlJM6wn4KyHsALilmjVrqlevXpo2bZrD+COPPKIzZ85o4sSJOnjwoGbOnKlVq1aZVnfmzJlatmyZfvzxR8XExOj8+fPq16+fJCkmJkbnzp1Tz549tWPHDh08eFBr1qzRU089pczMTKfqDBs2TPHx8frkk0+UlJSk4cOHa/fu3Ro8eLBpr+X555/X0aNH9cILL+jHH3/Uf/7zH40ePVpDhw51+IjvuqpVq6p169YaMGCAtm3bpsTERP3973+Xl5eXaT0BfyWEHQC3NXbs2GwfM1WrVk3vvPOOZs6cqdq1a2v79u15OrfnzyZMmKAJEyaodu3a2rJli1asWKFSpUpJkn01JjMzU5GRkapZs6ZiY2NVrFixHMPDrQwaNEhDhw7Viy++qJo1a2r16tVasWKFKleubNprKVOmjP773/9q+/btql27tp599lk9/fTTeu211276nHnz5ik4OFjNmzdXly5d9Mwzz8jf39+0noC/Epvx5w/dAQAALISVHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGmEHQAAYGn/D0ZjmM4fHqdBAAAAAElFTkSuQmCC)

![glove2hw3forcomparison.png](data:image/png;base64,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jmT7vAYFBanFYlFvb29NkSKF/vzzz3r79m2nCMaf6sSJE1qvXj1NnDixFi5c2K719vr16zpx4kSdN2+eAyv892zHpPPnz+u+fft0zZo12r9/f+3QoYOmT59e586dq6qOvxAwevRoffHihbZs2VIzZ86sqmoXqG1sdY4YMUKzZcsWqd36VqxYoatWrbJbdu/ePc2WLZtmyZLF7rx6//59TZYsme7cuVMXLVqkvr6+Tj2G9fDhw7p3716nP+78GytWrAgVmI8fP65NmjTRePHiaZ06dXTGjBl6/PhxXblypWbMmFEnTpyoqpHTBbZChQqhWpsfP36sqm9bRffu3av/+9//1M/PTw8fPhzh9UQ2QpCDvHuS7t27t6ZIkUKTJEmibdu21YULF+q6deu0Xbt2Wr58eR0yZIgeO3bMgdV+nO21bN26Vfv166f169fXjh07GuM17ty5oxMmTNCVK1fqX3/95chS38tW/5s3b3T16tU6d+5cXblypdHHev/+/dqnTx9t166dbt68We/fv+/Icj/q5cuXmiJFCp0/f76qqnbq1EmLFi2q27dv1zRp0qiHh4c2aNDAKbvy2bw7oN3Weli8eHEtWrSo9uvXL1QXS2fy5MkTLVGihKZPn167detmNxB//vz5Onv2bN29e7exbzmye+uZM2e0QYMG6u7ursWKFfvoMebq1at69uxZrVq1qrZs2TISq/wwW2ug7QTeqVMnjR49ugYEBOiqVav06dOnDq7w0926dUuXLFmiFSpUUE9PT23atKlTTuLwKS5duqTDhw/XRYsW6bp16947OP/Ro0f69ddfa+HChR0+3mD79u2aNWtWLVq0qLq7u+v27duNdbYLM++GtJCQEL19+7YmTZrU7gJCRCtRooQuW7ZMVd++x7ZjyPHjx7VOnTqaOnVqLV26tAYGBmqOHDk0ICBAVd+ev9KlS+e0Eyt97IKFMx53wqpx48ZGq//x48f13r17xrply5Zp3rx5NV68eBojRgwtW7asXdeziL6YM3z4cLVYLOrv76+vXr364PPduHFDAwICokRvpLAiBDmI7eA6ePBgbdiwodapU0cbNGhgdH0YMGCA3rp1y8FV/jPbl7hjx45pqlSpNG/evNq4cWP19fVVT0/PKDGw0fbBDwwM1FSpUqm3t7fmz59fa9asaZx03uXoq5Yfs3nzZq1Tp44+efJE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NEY3senTp2vnzp316NGjDq7y35k7d66mS5dOfXx8dPXq1bp+/Xr95ptvNFmyZMZ9ahz5perVq1eaOnVqzZAhg92U0vfu3dNFixZpkyZN1M/PT6tWrerwbmRLly7Vrl27Gi0ERYoUMa7Uq769mj927FhNmzatLlq0SFX/f0IBZxnvqfr2ODhnzhy7Lof37t3Tixcv6rNnz7RYsWLGMfLevXuaM2dOo0eAswa5j3m3tfPNmzfq7e2tXbt21SFDhmjnzp01Q4YMmjt3bv3999+N7Ww9fiLj7xYcHKzBwcHGNNg2hw8f1sSJE6vFYjEuwDvbBceIQAhyErdu3dKhQ4dqx44ddc6cOcbNU52R7cD06NEjXbt2re7atUuPHDmiqqo7d+7Url27av369bVNmzZOeUXWdhIOCQnR3377TadNm2asu3r1qv76669avXp1zZAhgzZq1MipuyQ+ffpUkyVLZhxQv/rqK+Nq4OPHjzUwMNBunIGz+PvJ7fXr1zp8+HBNnjy5tm/fXv/880+9evWqnjx5UpMkSWLcqC1Pnjx2zfiOdu7cOQ0ICNA0adIYg0afP3+uISEh+urVKy1WrJh269bNwVWGZnv/bVciCxQooDVq1ND//e9/Om7cOC1btqz6+/s7uMq3X4py5MihX375pS5ZssRoHSlXrpxmzZpVY8aMaXR9e/XqlZYrVy7UTWudkW0MwO+//64FCxY0umGNGzdOy5cv78jSwuz169f64sULI+QsX75ca9SoobFjx9Z48eJpw4YNde3atarq+C/nz54905UrV+qXX36pXl5eWrlyZbuu2ufPn9dJkyZplSpVNG3atNq6dWuHhbaRI0dqpkyZtGrVqjpmzBitVauW8T7avHz5UitVqqRlypT56BTHjlSpUiVNnDixdujQQbds2WI3df3z58+1QIECmj17dl26dKl+8cUXTnHc+beCg4M1b968WrduXT1//rz+9ddfWrNmTWP9gwcPdMWKFfrll19qmjRptEiRInr+/PlIC3tr1qzRBg0aaI4cObRZs2b6yy+/2IWhevXq2bUmmgEhCGFiuzJw+PBhLVy4sMaLF089PT01b968GhgY6NThTdX+KmT79u01RYoU2rhx41DbnThxQnv27Kk//fRTZJYXZteuXdMiRYrozZs39cKFCxo7dmzjpp1PnjzRKlWq6JQpUxxcZWi2v8PSpUvtBl9OnTpVfXx8NEOGDMYVZduXwqtXr2q8ePEcfoX2XZs3b9b8+fNrrFixtFGjRqG+5OXKlUt79uzpoOrs/f1E++5VvhUrVmiTJk2Mz3TLli2N8XGO/uK6c+dOLV++vBYoUMBoJbl586Y2atRI3dzcNDAwUIcNG6aVKlVSX19fffjwoUPr/bt33/cTJ07ooUOHjJYq2wDlwMBAnTp1qnp5eemMGTMcVWqYLV++XCtUqKD+/v7atm1bXbFihVqtVn39+rXev3/fqVq03t2Pb9y4oXPmzNHChQurt7e3durUye7zsH//fv3++++N6e0d1SJx48YNbd68uRYsWFDjxImjzZo1CxV05syZo1myZHG6/f5dkyZN0gwZMmjOnDl1wIABeuTIEeM9PXXqlJYsWVJjxoyp5cuXNy4mOfq482/cuXNH+/btq6VLl9YsWbLoV199pWXKlAl1L6zLly/r1KlTtWjRopE2XvrBgweaMGFCbd++vY4bN844x37xxRdGd+KnT58ak2uYoRVIlRCEfyl79uzarFkzPXXqlF67dk1/+uknLVSokFavXt1pp/R+90QWFBSkw4YN03z58qm7u7vRr/pdtmZjZ2M7CdpaqLJnz64DBw7UokWLaqtWrYztNmzYoPHjxze6IThb14Lg4GAtXLiwWiwW7dSpk926qVOnGjOtvXjxQu/cuaP16tXTMmXKOKja//fu+xgcHKwnTpzQoUOHqo+Pj8aPH1+HDRumkyZN0h9++EHTpElj/J0c/f7bnn/27NnavHlzzZIli3br1s3oama7ov/s2TO7qV2dwZs3b3TevHmaJ08eLV68uA4ZMkRXrFihP//8sxYoUECzZcum3333ndF9z5nYjodDhgzRTJkyqaurq5YoUUK7dOmiR48e1Xnz5mnOnDnV19dXO3To4OBqP92LFy/Uw8ND27Ztq998842WKlVK8+fPr99++63dBC2qzrEf+fv727WkBAcH68mTJ3Xo0KHq6+urKVKksLun17v3KXN0/QcOHNBSpUppokSJtHXr1sZMpefOndOSJUtqo0aNVNX5xm+8G2SePHminTt31mTJkmmxYsV06tSpxo2xg4OD9fr168Z9lxz9fv8XISEhunPnTu3WrZvx/eLdqb9trFarMXV5ZPzdmjZtakyDffv2bY0VK5Z+//33mj59ek2TJo3WrVvX7kblZkEIwifZtGmTEQi2b9+uPj4+oe5NsGvXLvX09HSaK9/v2rp1q6ZOndpujMzTp09179692rFjR02QIIH6+/tHqWmw27Vrp8eOHdOVK1dqrly51MvLSxctWqQhISH6559/avbs2Y1ZjZz1qtqlS5d07Nixmjx5co0bN64xU6Lq/58Ig4ODderUqZorVy67qUQdzdYPX/XtF8K9e/dqYGCgenl5qcVi0W+//db4IvXy5UuHnthtf/8tW7ZoihQptFGjRjphwgS1WCyaIkUKHTRoUKg+4s7o6dOn2qtXL82dO7fWq1dPp06dqk+ePHHKL0179uzRK1euqOrbweBubm46Z84c3bJli3bt2lULFSqkZcuW1X79+unx48c1KCjIaS8gvc/cuXO1Vq1axuOrV69q3759tXDhwlq6dGnt1KmT09yf5sWLFzpq1Cjjc/DuPbuePXumu3bt0nbt2mnChAk1X758xnghZ9qvQkJCdMGCBZonTx719fXVLFmyGPfns11ocbYQZKvn3fOPbWrvJEmSGJMgOOKmsxHh3df5+PFjo+tlypQptXLlyrp161aH1HXr1i0NCAgwbohaunRp44LprFmzNFmyZFqtWjW72evMghCEfzRw4EBNkiSJ8fj69euaPHlyown13TEzHTp00CZNmjjdl+4LFy4Y9W7YsEF37dplrLt//76uXbtW69Spo/HixdOyZcs61VSu77KdlH///XdNmTKl3rt3T9+8eaMTJ07U9OnTq7+/vyZNmlQzZsyodevWDfVzzsRW0+vXr/X48ePaoUMHdXV11YIFC9pNlW3jLF+oVN+GaovFooUKFbIbc3X//n3jxOft7a3169d3+JS1734Wc+TIob169VJV1YULF6qPj4926dJFo0ePriVLltTffvvN6b5Ivc/Fixe1Xr16mjt3bv3qq6908eLFGhIS4jT7+btjmZYtW6aLFi3Sli1b2m2zdetWbdq0qRYpUkSLFi3qNBN+fIp79+5p9+7dQ70m1bddyVq2bKkBAQFOOVX52rVr1WKxaKlSpfTYsWPG8jt37ujq1au1ZMmSWrJkSQdW+HFPnz7Vn376SVOkSKF58+Y1uo858+f2U6b2dqbj+391+PBh46LxjRs3dOrUqVqlShXNkCFDqPtlRYYXL17okiVL9OjRo3rmzBnNmjWrMUvioUOH9MsvvzTOuc68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)
![glove3hw3forcomparison.png](data:image/png;base64,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kWdfdLCiS5cuyfLly8XT01NSp04tlSpVstS+x4w9e/ZInz59pHXr1tKrVy9nl2OeAv/B1q1btUiRIjpo0KAEf+6LFy86PM6cObP27dtXR48erT169FB/f3+tUaOGzp49O8Fr+yeRkZGqqrpu3TrNnDmzzp49W8+dO6dJkybVsWPHqqrq3bt3NTw83JllOoiOjlZV1bfeektr1aqlqqpRUVGaNm1a3bx5s6qq7tixQ69du+a0Gl9U3rx5tUGDBtqwYUOtVKmSVq5cWfv27at79+51dmnPZH/PTJo0SfPnz69nz55VVdU0adLojBkzVFX10qVL+vjxYydVGFtERISqqs6ePVvz5Mmj/fv312+++UZtNptOmTLFYZvEILF9bqOiolRVtWfPnlqqVClt2rSpli1bVpMkSaIXLlxwcnXPd+nSJe3QoYPWr19f//jjD1V9sg+y74eswP76zps3TzNnzqzNmjXTSpUqadmyZfX111/XOXPm6MOHD51cZcI7fPiw1q1bV5MmTapvvPGGnj592tklaatWrbRFixZ6+/Zt3blzp3bt2lX9/f21cePGOn36dL19+7azS/xH9n3l3LlztVSpUlqoUCHNkyeP5suXT3/77TcnV/fvRUVF6ZgxYzR58uT6zTffOLsc0whS+NfsB7TFixdrxowZdfDgwfro0SPj4BLf6tWrp+3bt9fff/9dDx48qE2bNjWe++7duzp//nxt27atlilTRl977TX9/fffE6QuMypVqqRDhw5VVdUFCxZozpw5jR36N998o7/88oszy4vl7t27Wq1aNePEvXbt2tq6dWtVVX306JG+/fbbOmDAAEudzNvZ36+bN2/W8uXLGyc4p06d0v79+2uFChU0ICBAhw4dqleuXHFmqc8UGRmp5cuX1y+//FJVVXv16qX+/v4aFRWlERER2rdvX/3iiy8sF068vLz0888/V1XVcePGabFixfThw4caFRWlU6ZM0ePHjzu5QnMSw+fWvi/ct2+fpkqVSg8dOqSqqtWrV9du3bqpquq5c+d09+7dTqvx7+bNm6fjxo3TZcuW6fnz5/X+/ftar1499fLysvRFjsDAQP3000+Nx7NmzdL69etr+fLl9a233tI1a9Y4r7gEFjPoLl26VH19fTV9+vQ6atSoBA8r9s/A1atXNSgoSDdt2uSwftGiRRoYGKhFixbV7t27J9i5y78R83XNnDmzfvbZZ6qqOmDAAC1RooRGRERoZGSknjx50lIXG8wYMWKEVqhQQffv36+qaum/R0zW6ecEy4uIiBARkStXrsjjx4/FZrNJdHS0NG3aVEaNGiWrV6+WgwcPJkj3uTt37kjhwoXl6tWr8s4778i0adPk4cOH8vDhQxERSZs2rbRo0UJGjx4t7du3l8ePH1umv7bIky4EYWFhkiZNGilYsKCIiPTs2VOGDBkiGTNmlMjISNm5c6esWLHCyZU6Sps2rWTPnl3u3bsnf/75p+zfv1+GDRsmIiIuLi7y559/Svr06S3XxUz/v8tGdHS0HD58WAoVKmTUmDdvXhkzZoyMHj1asmXLJnPnzpUbN244ueKnS5o0qeTKlUvSp08vERERMmPGDBk1apQkSZJEkiVLJlevXpVz5845fcxXzAkCjh8/Lh4eHtK6dWu5e/eujBo1SoYMGSIpU6aUmzdvyp49e2T//v1OrPbFJabPrX0/vGzZMnn99delaNGisnjxYjly5IgMHjxYRET++OMPmTZtmly8eNGZpYrIk/fMZ599Jv3795eVK1dKixYtpEuXLvL2229LmjRppHXr1rJ8+XJLDK5XVWOg/MGDByVdunSSO3duY32HDh1k+vTp0qRJE9m9e7csW7bMWaUmiJh/k5if/caNG8sff/whAwcOlAkTJoifn5+sXr06weqyfwYmTJggGzdulO3btzusb968uUyfPl1atWol9evXt1TX/7+zdzmcNWuWeHp6yjvvvCOXLl2SqVOnysiRIyVZsmSyfft2mTx5spw9e9bJ1T6b/f1x48YNWbNmjZw7d06ioqLk3r17MmDAAHF1dZVu3brJlStXLP33cODMFIfEIWbrwsOHD7VWrVqaN29ebd++vQ4ZMkS//fZbPXr0qBYrVkxz5sypO3fuVFVNkKsiO3bs0KCgIPX399eUKVPqiBEj9P79+7G2O3/+fLzX8m906NBB+/fvryNGjNBKlSoZXYeCg4M1W7ZsunHjRlV17pWZvz/3tGnTNF++fJo+fXodMGCAqj55j8yaNUszZMhgudaQmL766it1d3fXTJky6fLly2Otj46O1q1btzqhshcTHR2tffv21TJlymi5cuW0bdu2xro9e/Zo6tSpLdGNJqbQ0FAtUqSIrl27Vt944w197bXXjHV//PGHZs+e3ei6lVhY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Jww3b940TkDtNwFVfdK1Llu2bJoyZUqHHeXjx4/j/Yrn+vXrNX/+/MbzREZGGvXOmDFD27Rp89TWMmeJjo7We/fuadOmTbVLly567do1bdiwobZq1UrXr1+vW7Zs0dKlS1siAMY8UZw1a5YuWLBADxw4oKpPWv1u3LihZcuW1YoVK1r+pp4PHz7UXLly6Q8//OCw3B5I3nzzTSdV9mxRUVHG3+DPP//Uo0ePOlws2LZtm6ZPn97pE0s8y9y5c7VAgQJ66dIlVX3yntm2bZu+//77WqZMGc2fP79u2bLFuUW+IPuJSZ8+fbRChQoOfwf7/9966y0dPHiwM8p7ISdPntSPPvpIc+TIoYUKFXI4IXOmkJAQrVevnubIkUMbNGigNptNJ02a5OyyninmpAoFCxbU9evXq+qT1ql58+ZpixYttHr16tq0aVNjf/mysr8We/bs0T179jisGzRokLq6uup7772ndevWVR8fnwSv77PPPtOaNWsan197vceOHVN3d3fLfAZexJ49e7RkyZJPDX979uzRkSNHGl2KrWr79u1aqFAhTZ06tb733nt67NgxhzD4448/apYsWTRnzpwOXf2seD/KpyFI4ansJ3J37tzRRo0aqZeXl9aoUUNtNpvOnj3bYdu33norwfuCHz58WNOkSaODBg0yBn/bBQQEGF0LrGb69Onq5+en2bJl06pVqxoH3OPHj2vOnDn12LFjTq0v5s765MmT6urqqpUrV9b06dOrr6+vtmzZUvv27aufffaZpkyZUj/++GMnVvt80dHRGhYWpuXLl9evv/7aWG5/b3/66afq5+dn2Step0+fVpvNphUrVtTcuXNr586ddezYsbplyxadP3++urm56eTJky13FfLixYtarlw59fX1dehaGxISoosXL9Y2bdo4XJBJDH7++WfNlSuXLl++3KEL8alTpzR9+vTGuCln/S3sNR08eFAnTZqk9erV08GDB+vatWv1/v37GhkZqdu2bdMWLVpoyZIlnVLj3wUGBmpAQIDev39f161bp2nTpjVaiA8ePGiZllbV/+0zLl26pKlTp3a4ELBkyRL9/vvvdcqUKTp8+HCtWLFiohr7Z5b9tXj8+LHmzZtX33nnnVjjjAYPHqxeXl765ptvOuWGz8uWLVObzWZMXqL6v89m48aN9aOPPkrwmv6tS5cuaebMmY2bsMfc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)

*Discussion*

We decided to comapre the BERT embeddings to GloVe, as BERT is considered a sophisticated model with more meaningful vector representations. As it is based upon a Transformer model, it maintains context more effectively. We took a pretrained BERT model and extracted the outputs of the 180 concepts that we used in HW3. As the BERT embeddings are much larger than those of GloVe, we ran into a matrix multiplication issue, as the fMRI data that was used had been adapted to fit those vectors.

To solve this issue, we performed a PCA on both the brain data, as well as the BERT embeddings. Intially we aimed for a cumulative explained variance of 80%, but then thought to perform a cross-validation and compare different explained variance thresholds. We ended up choosing 85%, as it had the ebst results (see above). This meant reducing both BERT and fMRI vectors to 71 principal compnents.

*Results*

The number of successful concepts for BERT embeddings was 133, while GloVe has 134 successful concepts. However, we believe that this difference alone may not be sufficient to determine which model has better results, especially becuase GloVe betters BERT only by 1 concept.

When comparing the top 15 successful concepts for BERT, we observe that although some words are similar to those of GloVe. BERT includes more complex words such as "investigation", "willingly" & "construction" that are not present in GloVe. This suggests that BERT performs better with more intricate vocabulary compared to GloVe, which excels in capturing simpler and more standard words.

Looking at the top 15 failed concepts, BERT includes simple and everyday words like "plan," "weak,", "toy" & "bag". On the other hand, GloVe's failures consist of more complex words like "argumentatively", "mathematical" & "emotionally". This again points to GloVe's success with simpler words while struggling with more complex langauge, while BERT being the opposite.

An area, however, in which BERT embeddings slightly outperformed GloVe's is the accuracy scores. For all top 15 concepts, BERT's accuracy score did not exceed 4, while GloVe only managed an accuracy below 4 in its top 5 concepts. Also for the failed concepts, all of GloVe's were above 150, while only 7 of BERT's top 15 score above 150. We can see that although the binary measure of successful/failed produced similar performance, for the rank-based accuracy metric, BERT was more impressive.

In general, although BERT's results were by no means bad, it did not perform as well as we expected it to. Another way in which to account for this difference is perhaps also the manner in which BERT is trained. It is a transformer-based model, whose goal is to maintain context. Since this task focused on single-word concepts,  perhaps it did not perform as well owing to the lack of context and the isolation of each word.

In summary, while GloVe seems to perform better with simpler words, BERT shows strength in handling more complex and nuanced vocabulary.

## Section B

> Overview of experiments performed in the paper 'Toward a universal decoder of linguistic meaning from brain
activation.' Pereira, F., Lou, B., Pritchett, B., Ritter, S., Getshamn, S.J., Kanwisher, N., Botvinicj, M. & Fedorenko, E. (2018).

Pereira et al. performed 3 different experiments in their analysis. The used individual concepts (words) as stimuli and tested whether the decoder could generalize new concepts. Each concept was presented in the context of a sentence, an image, and in a word cloud with 5 similar words, all intended to reduce  ambiguity, and then combined all 3 contexts (paradigms) to produce 1 brain image per participant per word.


Experiments 2 & 3, on the other hand used text passages as stimuli, and tested whether a decoder trained on individual concept imaging data could decode semantic vectors from sentence imaging data. Experiment 2 used a 4 sentence passage describing a concept and providing basic information (Wikipedia-style). Experiment 3 also included narrative passages, in addtition to what was presented in Experiment 2. Sentences were presented individually, and the scans from each sentence were combined together to produce a scan for each participant on each concept. To produce a semantic vector for a sentence, the average was taken across all word embeddings in each sentence (i.e. the true embedding). Evaluation took place in 3 pairwise classification tasks, first taking sentences from different topics (e.g. an animal and a musical instrument), then taking different sentences from different passages within the same topic (e.g. two musical instruments), and then taking different sentences from the same passage. The model was the one trained in experiment 1.

In summary, the difference between Experiments 2 and 3 are minor, being reflected only in the actual stimuli used themselves, and the addition of a narrative passage as a stimulus. However, experiment 1 differs from 2 & 3 both in the type of stimulus (single words as opposed to passages) and in the goal of the analysis (also in the number of participants and the success of the results, but since we are trying to recreate the computational method, this is less interesting to us for the purposes of the project). While Experiment 1 trained the decoder and tested its ability to generalise concepts from given brain data, the latter two used a decoder pre-trained on individual concepts and tested whether it could decode brain-data for sentences.

##Section C
> Training on Data from Experiments 2 & 3 in Pereira et al.
"""

train_matrix = learn_decoder(data_c, vectors)

"""Note that the calculate_rank_sentences function is a modified version of the calculate_rank function that was used above as part of a k-fold rank-based accuracy evaluation procedure, that receives a pre-trained model."""

ranks_exp2 = calculate_rank_sentences(train_matrix, fmri_exp2, vectors_exp2, concepts_exp2)

ranks_exp3 = calculate_rank_sentences(train_matrix, fmri_exp3, vectors_exp3, concepts_exp3)

"""##Section D
> Analysing the results of Section C
"""

successful_topics_2,failed_topics_2 = successful_failed_topics(data_exp2,ranks_exp2)

successful_topics_3,failed_topics_3 = successful_failed_topics(data_exp3,ranks_exp3)

plot_concepts(successful_topics_2,"Successful ", "Broad Topics ", "Exp2")

plot_concepts(failed_topics_2,"Failed ", "Broad Topics ", "Exp2")

plot_concepts(successful_topics_3,"Successful ", "Broad Topics ", "Exp3")

plot_concepts(failed_topics_3,"Failed ", "Broad Topics ", "Exp3")

"""*Results*

Keeping in line with the methods used in HW3 & above, to identify the more/less successful topics we computed the average rank for each topic. If the average rank of a topic was lower than half the length of the data, we classified it as successful, otherwise we considered it failed.

Experiments 2 and 3 share similarities in terms of using text passages as stimuli and testing the decoder's ability to decode semantic vectors from brain imaging data. The main difference between the two experiments lies in the nature of the stimuli used. In experiment 2, the stimuli were four-sentence passages that described a concept and provided basic information in a Wikipedia-style format. On the other hand, experiment 3 included narrative passages in addition to the stimuli used in experiment 2.

Despite the similarities, there are some variations in the outcomes of the two experiments. In experiment 2, out of the 24 key passages used, 21 were successfully decoded by the GloVe-based decoder, while 3 failed. The successfully decoded key passages covered a range of topics such as body parts, humans, drinks, furniture, and more. However, the decoder struggled to accurately decode key passages related to professions, vegetables, and animals.

In experiment 3, the outcomes were slightly different. Out of the 24 key passages used, 19 were successfully decoded, while 5 failed. The successful key passages included topics like dreams, stress, castles, taste, and painting. On the other hand, the decoder faced difficulties decoding key passages related to beekeeping, owls, lawn mowers, pyramids, and pharmacists.

It is also interesting to note that on a whole, the accuracy scores of the top 15 successful concepts in experiment 3 were better.

The difference in outcomes between experiment 2 and experiment 3 could be attributed to the addition of narrative passages in the latter. The inclusion of narrative elements might have introduced more complex and diverse linguistic patterns, requiring the decoder to generalize and decode semantic information from a broader range of contexts. This increased complexity may have contributed to the slightly lower success rate in experiment 3 compared to experiment 2.

It is important to keep in mind that in both cases, the decoder was trained on individual words, and tested on both sets of sentences. This step-up in the complexity of the task indicates that on the whole, teh results are impressive.

Overall, both experiments demonstrated the decoder's ability to decode semantic vectors from brain imaging data based on textual stimuli. However, the specific stimuli used in each experiment, particularly the inclusion of narrative passages in experiment 3, led to slightly different outcomes, with experiment 2 yielding a higher success rate.

# Part 2 - Semi-structured Tasks

## Part A
> Training the decoder on both GloVe and BERT for sentence representations

The sentence representations with BERT
"""

ranks_semi_bert, avgs_semi_bert = train_decoder(fmri_exp2, sentences_exp2_bert, 0, True)

successful_topics_semi_bert, failed_topics_semi_bert = successful_failed_topics(data_exp2, ranks_semi_bert)
plot_concepts(successful_topics_semi_bert, "Successful ", "Broad Topics ", "Exp2 BERT")

ranks_semi_exp2, avgs_semi_exp2 = train_decoder(fmri_exp2, vectors_exp2, 0 , True)

successful_topics_semi_exp2, failed_topics_semi_exp2 = successful_failed_topics(data_exp2, ranks_semi_exp2)
plot_concepts(successful_topics_semi_exp2, "Successful ", "Broad Topics ", "Exp2")

ranks_bert = list(avgs_semi_bert.values())
ranks_glove = list(avgs_semi_exp2.values())
x = np.arange(1, 33, 1)

plt.figure(figsize=(10,6))
plt.plot(x, ranks_bert, label='BERT', marker='o', color='b')
plt.plot(x, ranks_glove, label='GloVe', marker='o', color='r')
plt.legend()
plt.xlabel('Fold')
plt.ylabel('Avg Accuracy Score')
plt.title('Average Accuracy Score for GloVe & BERT Embeddings')
plt.show()

"""For this part of the project, we took a pretty similar approach to HW3 & the first part of the Structured Task. We decided to train and evaluate both models in a k-fold cross-validation method with a rank-based accuracy assesment. As there were 384 sentences, we split them into folds of 12 (as opposed to 10 for the words), giving us 32 folds.

Similar to our results with the words, BERT performed similar to the glove embeddings, with both succeeding in 22/24 broad topics. However, just as with the words, BERT's actual accuracy scores indicated slightly better results, both in terms of the topics in which it succeeded and failed, and in the average accuracy score for each fold.

These results, however, are slightly disappointing, as we expected BERT to outperform GloVe when it came to sentences - we know that BERT is supposed to surpass most other models (except perhaps GPT) when it comes to sentences and maintaininng context. We will perofrm a PCA decomposition to the BERT vectors to try and improve the results.
Owing to the computational resources required, we will not perform a cross-validation for the best explained varaince threshold as above, but rather use 0.85 from the outset.
"""

n_components_bert = pca_cumulative_var("BERT Vectors ", sentences_exp2_bert, 0.85)
n_components_data = pca_cumulative_var("fMRI Data ", fmri_exp2, 0.85)

pca = PCA(n_components=max(n_components_bert, n_components_data), svd_solver = 'full')
pca.fit(sentences_exp2_bert)
bert_sentences_pca = pca.transform(sentences_exp2_bert)
pca.fit(fmri_exp2)
fmri_exp2_pca = pca.transform(fmri_exp2)
pca.fit(vectors_exp2)
glove_exp2_pca = pca.transform(vectors_exp2)

ranks_semi_bert, avgs_semi_bert = train_decoder(fmri_exp2_pca, bert_sentences_pca, 0, True)

successful_topics_semi_bert, failed_topics_semi_bert = successful_failed_topics(data_exp2, ranks_semi_bert)
plot_concepts(successful_topics_semi_bert, "Successful ", "Broad Topics ", "Exp2 BERT")

ranks_semi_exp2, avgs_semi_exp2 = train_decoder(fmri_exp2_pca, glove_exp2_pca, 0 , True)

successful_topics_semi_exp2, failed_topics_semi_exp2 = successful_failed_topics(data_exp2, ranks_semi_exp2)
plot_concepts(successful_topics_semi_exp2, "Successful ", "Broad Topics ", "Exp2")

ranks_bert = list(avgs_semi_bert.values())
ranks_glove = list(avgs_semi_exp2.values())
x = np.arange(1, 33, 1)

plt.figure(figsize=(10,6))
plt.plot(x, ranks_bert, label='BERT', marker='o', color='b')
plt.plot(x, ranks_glove, label='GloVe', marker='o', color='r')
plt.legend()
plt.xlabel('Fold')
plt.ylabel('Avg Accuracy Score')
plt.title('Average Accuracy Score for GloVe & BERT Embeddings')
plt.show()

"""These results are the opposite of what was expected - although both models improved significantly, GloVe outperformed BERT in terms of accuracy. Although this is surprising, it indicates that GloVe is also a very good model, much better than we thought. Additionally, we can attribute the results to the manner of evaluation - although theorectically, BERT is better at maintain context across sentences, the nature of this task still relates to each sentence as if it were a single word - by averaging across all words in the sentence and taking a single-vector representation of a sentence, it effectively is relating to the sentence as if it were a single word. This perhaps could be the reason that GloVe and BERT performed similarly across all tasks, whether sentences or words. We would expect to see a more significant difference in next-word prediction tasks.

### Don't use
"""

# ignore for now, huge model that eats all of the RAM
#del outputs
tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased")
model = BertModel.from_pretrained("bert-base-uncased")

inputs = tokenizer(sentences, return_tensors="pt", padding=True)
outputs = model(**inputs)

last_hidden_states = outputs.last_hidden_state
vectors_bert = last_hidden_states[:,1,:].detach().numpy()

thresholds = [0.75, 0.8, 0.85, 0.9]
for threshold in thresholds:
  print(f'--------------------------- PCA Threshold: {threshold} -----------------------------------------')
  n_components_bert = pca_cumulative_var("Bert Vectors ", embeddings, threshold, cv=True)
  #n_components_data = pca_cumulative_var("fMRI Data ", fmri_exp2, threshold, cv=True)
  #n_components_glove = pca_cumulative_var("GloVe Vectors ", vectors_exp2, threshold, cv=True)
  pca = PCA(n_components=n_components_bert, svd_solver = 'full')
  pca.fit(embeddings)
  bert_pca = pca.transform(embeddings)
  pca.fit(data)
  data_pca = pca.transform(data)
  pca.fit(vectors_exp2)
  glove_pca = pca.transform(vectors_exp2)
  trained_bert = learn_decoder(data_pca, bert_pca)
  trained_glove = learn_decoder(data_pca, glove_pca)
  test_exp2_bert = calculate_rank_sentences(trained_bert, fmri_exp2, vectors_exp2, concepts_exp2)
  test_exp2_glove = calculate_rank_sentences(trained_glove, fmri_exp2, vectors_exp2, concepts_exp2)
  print('')
  print(f'---BERT---')
  successful_topics_3, failed_topics_3 = successful_failed_topics(data_exp2, test_exp3_bert)
  print(f'---GloVe---')
  successful_topics_3, failed_topics_3 = successful_failed_topics(data_exp2, test_exp3_glove)
  print('')
  print('')

pca = PCA(n_components=70, svd_solver = 'full')

#PCA bert
pca.fit(embeddings)
bert_pca = pca.transform(embeddings)
pca.fit(vectors_exp2)
glove_pca = pca.transform(vectors_exp2)
pca.fit(fmri_exp2)
data_pca = pca.transform(fmri_exp2)

bert_encoder = learn_decoder(fmri_exp2, embeddings)
glove_encoder = learn_decoder(fmri_exp2, vectors_exp2)

trained_bert = learn_decoder(data_pca, bert_pca)
trained_glove = learn_decoder(data_pca, glove_pca)

test_exp3_bert = calculate_rank_sentences(trained_bert, data_pca, glove_pca, concepts_exp2)
test_exp3_extracts = calculate_rank_sentences(trained_glove, data_pca, glove_pca, concepts_exp2)

sum(test_exp3_bert.values()) / len(test_dict)

successful_topics_3, failed_topics_3 = successful_failed_topics(data_exp3, test_exp3_bert)
plot_concepts(successful_topics_3,"Successful ", "Broad Topics ", "Exp3")

successful_topics_3_extracts,failed_topics_3_extracts =successful_failed_topics(data_exp3,test_exp3_extracts)
plot_concepts(successful_topics_3_extracts,"Successful ", "Broad Topics ", "Exp3")

"""## Part B
> Build a brain-encoder model
"""

def run_regression(neural_data, x, xT, xTx):
  warnings.filterwarnings("ignore")
  voxel_r2s = []
  significant = []
  cosine_similarities = []
  significant_similarities = []
  p = x.shape[1]
  n = neural_data.shape[1]
  for i in tqdm(range(neural_data.shape[0])):
    y = neural_data[i]
    b = np.matmul(xT, y)
    lse = np.matmul(xTx, b)
    Y_hat = np.matmul(x, lse)
    Y_mean = y.mean()
    SSR = sum((Y_hat - Y_mean)**2)
    #SSres = sum((y-Y_hat)**2)
    SST = sum((y-Y_mean)**2)
    #r2 = 1-((SSres/(n-p))/(SST/(n-1)))
    r2 = SSR/SST
    voxel_r2s.append(r2)
    sim = cosine_similarity(y, Y_hat)
    cosine_similarities.append(sim)
    if r2 > 0.75:
      significant.append(i)
      significant_similarities.append(sim)
      cosine_similarities.append(cosine_similarity(y, Y_hat))

  print(f' Number of significant voxels: {len(significant)}, which is {100*len(significant)/neural_data.shape[0]}%')
  print(f' Mean Cosine Similarity of Significant Voxels is: {np.mean(significant_similarities)}')
  return voxel_r2s, significant, cosine_similarities

def regression_analysis(neural_data, word_vectors):
    pivot = np.array(neural_data).T.astype(np.float64)
    x_0 = np.ones(pivot.shape[1]).T
    x = np.insert(word_vectors.astype(np.float64), 0, x_0, axis=1)
    xT = x.T
    a = np.linalg.inv(np.matmul(xT, x))
    voxel_r2s, significant, similarity_scores = run_regression(pivot, x, xT, a)
    return voxel_r2s, significant, similarity_scores

glove_r2s, glove_significant, glove_predicted = regression_analysis(fmri_exp2, vectors_exp2)

bert_r2s, bert_significant, bert_predicted = regression_analysis(fmri_exp2, sentences_exp2_bert)

x = np.arange(1, fmri_exp2.shape[1]+1, 1)
plt.figure(figsize=(10,6))
plt.plot(x, bert_r2s, label='BERT R2', color='b')
plt.plot(x, glove_r2s, label='GloVe R2', color='r')
plt.legend()
plt.xlabel('Voxel')
plt.ylabel('R2 Score')
plt.title('R2 Scores for GloVe & BERT Embeddings')
plt.show()

"""Although the original results were encouraging, we can see that the R2 scores for the BERT embeddings are greater than 1, which actually indicates a terrible fit. Let's try PCA, and reduce the BERT embeddings to 300 components, to match the dimension of the GloVe embeddings."""

pca = PCA(n_components=300, svd_solver = 'full')
pca.fit(sentences_exp2_bert)
bert_sentences_pca = pca.transform(sentences_exp2_bert)

bert_r2s, bert_significant, bert_predicted = regression_analysis(fmri_exp2, bert_sentences_pca)

x = np.arange(1, fmri_exp2.shape[1]+1, 1)
plt.figure(figsize=(10,6))
plt.plot(x, bert_r2s, label='BERT R2', color='b')
plt.plot(x, glove_r2s, label='GloVe R2', color='r')
plt.legend()
plt.xlabel('Voxel')
plt.ylabel('R2 Score')
plt.title('R2 Scores for GloVe & BERT Embeddings')
plt.show()

"""We can see that the PCA has had a positive impact on the results. For both embeddings, the predicted vectors have an average similarity score of 0.9, and while 96.77% of voxels were deemed significant for the GloVe model, 94.62% were significant for the BERT model. We believe that owing to the success of both models, the high prediction similarity and the high number of relevant voxels, that brain-encoding models are successful and produce significant results. The small difference in the number of significant voxels may refelct a number of different factors, both neural, linguistic and the manner in which the models encode, and thus further research would be required to account for this difference, which is beyond the scope of this research.

# Unstructured Task

**To Do - In Descending Order of Importance**


1) Run Debiasing on words from that came out us very biased in the analysis part

2) Evaualte debiasing success by re-running above analyses

3) Take from HW3 the word pattern prediction task with gender specific words, see if debiasing impacts the results

**Probably Not Happening**

4) Analysing the sentences and seeing if there is anything interesting there that might exhibit bias which we could use

5) Taking bert and glove embeddings of races and using steps 1-3 above to calculate racial biases

6) Fix Soft Debias

**Almost Definintely Not Happening**

7) Fix cluster plottings with PCA/TSNE

8) Statistical Analysis

9) Fix regression part of Semi-Structured

**Deadline - Monday starting on report, Tuesday finishing report**

Whatever is not done by then is not happening

## Utility Functions
"""

def create_gender_vector(embedding='glove', male=True):
  male_list = ['he', 'son', 'his', 'him', 'father', 'man', 'boy', 'himself', 'male', 'brother', 'sons', 'fathers', 'men', 'boys', 'males', 'brothers', 'uncle', 'uncles', 'nephew', 'nephews']
  female_list = ['she', 'daughter', 'hers', 'her', 'mother', 'woman', 'girl', 'herself', 'female', 'sister', 'daughters', 'mothers', 'women', 'girls', 'females', 'sisters', 'aunt', 'aunts', 'niece', 'nieces']
  words = male_list if male else female_list
  if embedding == 'glove':
    vectors = get_glove_embeddings(words)
  else:
    inputs = tokenizer(words, return_tensors="pt", padding=True)
    outputs = model(**inputs)
    last_hidden_states = outputs.last_hidden_state
    vectors = last_hidden_states[:,1,:].detach().numpy()
  return np.mean(vectors, axis=0)

def find_vector_from_word(word, vectors):
    return vectors[np.where(concepts==word)[0][0]]

def get_neutral_extremtities(distances, threshold):
    sorted_distances = sorted(distances)
    count = len(distances)
    index = int(count * threshold)

    lower = sorted_distances[:index]
    upper = sorted_distances[-index:]

    return max(lower), min(upper)

def neutral_dist(male, female, vectors, indices, bins=10, threshold=0.05):
    distances = []
    neutral_vector = np.zeros(vectors.shape[1])
    for idx in indices:
      dist_m = cosine_similarity(male, vectors[idx])
      dist_f = cosine_similarity(female, vectors[idx])
      neutral_vector += vectors[idx]
      distances.append(dist_m-dist_f)
    neutral_vector = neutral_vector/vectors.shape[0]
    sns.displot(distances, bins=bins, kde=True).set(xlabel='Word Similarity Difference Between Genders', title='Distribution of Neutral Word Similarity Measures')
    l, u = get_neutral_extremtities(distances, threshold)
    return l, u, neutral_vector

def calculate_gender_bias(word, male, female):
    dist_m = cosine_similarity(male, word)
    dist_f = cosine_similarity(female, word)
    return dist_m, dist_f

def create_bias_dict(male, female, vectors, lower, upper, concepts):
      biases = {}
      for i, word in enumerate(concepts):
          word_data = {}
          dist_male, dist_female = calculate_gender_bias(vectors[i], male, female)
          diff = dist_male - dist_female
          if diff < lower or diff > upper:
            bias = round(diff, 8)
            bias_to = 'Male' if bias > 0 else 'Female'
          else:
            bias = 'Unbiased'
            bias_to = 'None'
          items = [('Score', round(diff, 8)), ('Bias', bias),  ('Biased To', bias_to)]
          word_data.update(items)
          biases[word] = word_data
      return biases

def prediction_analysis(preds, vectors, word_list, male_label, female_label, n_clusters, centroids):
    pred_dict = {}
    for i, word in enumerate(word_list):
        if preds[i] == male_label:
          label = 'Male'
        elif preds[i] == female_label:
          label = 'Female'
        else:
          label = 'Neutral'
        pred_dict[word] = label
    print(pred_dict)
    plt.figure(figsize=(8, 6))
    for i in range(n_clusters):
        cluster_points = vectors[preds == i]
        if i == male_label:
          plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f"Male Cluster")
        elif i == female_label:
          plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f"Female Cluster")
        else:
          plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f"Neutral Cluster")
    for i, txt in enumerate(word_list):
        plt.annotate(txt, (vectors[i, 0], vectors[i,1]))
    plt.scatter(centroids[:, 0], centroids[:, 1], c='black', marker='x', label='Centroids')
    plt.title(f'K-Means Clustering of Predicted Vectors')
    plt.legend()
    plt.show()

def run_kmeans_analysis(male, female, neutral, vectors, concepts, reduction=None, embedding='Glove', to_predict=None, words_to_predict=None, show_names=False):
    kmeans = KMeans(n_clusters=3, init=[male, female, neutral]).fit(vectors)
    labels = kmeans.labels_
    centroids = kmeans.cluster_centers_
    male_cluster = []
    female_cluster = []
    for i, label in enumerate(labels):
        if label == 0:
          male_cluster.append(concepts[i])
        elif label == 1:
          female_cluster.append(concepts[i])
    print(f'The Words Clustered with Males are: {male_cluster}')
    print(f'The Words Clustered with Females are: {female_cluster}')

    #Reduce Dimension to Plot
    if reduction == 'tsne':
      tsne = TSNE(n_components=2)
      plot_vectors = tsne.fit_transform(vectors)
    elif reduction == 'pca':
      pca = PCA(n_components=2)
      plot_vectors = pca.fit_transform(vectors)
    else:
      plot_vectors = vectors

    # Plot the clusters
    cluster_names = ['Male', 'Female', 'Neutral']
    plt.figure(figsize=(8, 6))
    for i, name in enumerate(cluster_names):
        cluster_points = plot_vectors[labels == i]
        plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f"{name} Cluster")
    plt.scatter(centroids[:, 0], centroids[:, 1], c='black', marker='x', label='Centroids')
    if show_names:
        for i, txt in enumerate(concepts):
            plt.annotate(txt, (plot_vectors[i, 0], plot_vectors[i,1]))
    plt.title(f'K-Means Clustering of {embedding} Word Vectors')
    plt.legend()
    plt.show()

    if embedding != 'FMRI':
        preds = kmeans.predict(to_predict)
        prediction_analysis(preds, to_predict, words_to_predict, 0, 1, 3, centroids)

def run_random_kmeans(n_clusters, vectors, concepts, to_predict, words_to_predict, show_names=False):
    concepts = np.array(concepts)
    kmeans = KMeans(n_clusters=n_clusters, init='random', n_init='auto').fit(vectors)
    labels = kmeans.labels_
    centroids = kmeans.cluster_centers_
    for i in range(n_clusters):
        exec(f"cluster_{i} = concepts[labels=={i}]")
        exec(f"print('Cluster {i+1}')")
        exec(f"print(cluster_{i})")

    # Plot the clusters
    plt.figure(figsize=(10, 8))
    for i in range(n_clusters):
        cluster_points = vectors[labels == i]
        plt.scatter(cluster_points[:, 0], cluster_points[:, 1], label=f"Cluster {i+1}")
    if show_names:
        for i, txt in enumerate(concepts):
            plt.annotate(txt, (vectors[i, 0], vectors[i,1]))
    plt.scatter(centroids[:, 0], centroids[:, 1], c='black', marker='x', label='Centroids')
    plt.title(f'K-Means Clustering of Word Vectors')
    plt.legend()
    plt.show()

    male_cluster = labels[66]
    female_cluster = labels[67]
    preds = kmeans.predict(to_predict)
    prediction_analysis(preds, to_predict, words_to_predict, male_cluster, female_cluster, n_clusters, centroids)

def plot_top_biases(bias_dict, embedding):
  data = {}
  words = []
  bias = []
  gender = []
  for k, v in bias_dict.items():
   if v['Biased To'] != 'None':
    bias.append(abs(v['Bias']))
    words.append(k)
    gender.append(v['Biased To'])
  data.update([('Words', words), ('Bias', bias), ('Gender', gender)])
  order = bias.sort()
  pal = ['blue', 'hotpink']

  sns.barplot(x='Words', y='Bias', data=data, hue='Gender', dodge=False, order=order, palette=pal)
  plt.title(f'Biased Concepts for {embedding} Embedding')
  plt.xticks(rotation=75)
  plt.ylabel("Bias Score")
  plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0)

"""## Data"""

tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased")
model = BertModel.from_pretrained("bert-base-uncased")

inputs_1 = tokenizer(list(concepts), return_tensors="pt", padding=True)
outputs_1 = model(**inputs_1)
last_hidden_states_1 = outputs_1.last_hidden_state
concepts_bert = last_hidden_states_1[:,1,:].detach().numpy()
inputs_2 = tokenizer(['male', 'female'], return_tensors="pt", padding=True)
outputs_2 = model(**inputs_2)
last_hidden_states_2 = outputs_2.last_hidden_state
man_woman = last_hidden_states_2[:,1,:].detach().numpy()

concepts_glove = get_glove_embeddings(concepts)

# extracting relevant features for analysis. Note that indices89 & 90 (lady and king) are non gender-neutral
neutral_indices = [3, 4, 5, 6, 8, 9, 12, 13, 14, 17, 18, 21, 22, 23, 25, 27, 31, 33, 35, 37, 39, 43, 42, 44, 45, 46, 47, 48, 51, 52, 53, 55, 58, 60, 65, 66, 67, 70, 71, 72, 73, 78, 79, 81, 83, 84, 87, 91, 92, 93, 94, 95, 97, 98, 100, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 115, 116, 118, 119, 120, 121, 126, 127, 128, 129, 131, 132, 133, 135, 136, 139, 140, 141, 42, 143, 144, 145, 147, 148, 149, 150, 151, 152, 156, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 172, 174, 176, 177, 178, 179]
ba_concept_indices = [0, 1, 2, 7, 10, 11, 15, 16, 19, 20, 24, 26, 28, 29, 30, 32, 34, 36, 38, 40, 41, 49, 50, 54, 56, 57, 59, 61, 62, 63, 64, 68, 69, 74, 75, 76, 77, 80, 82, 85, 86, 88, 89, 90, 96, 99, 101, 104, 114, 117, 122, 123, 124, 125, 130, 134, 137, 138, 146, 153, 154, 155, 157, 171, 173, 175]
ba_concepts = []
ba_fmri_data = []
ba_bert = []
ba_glove = []
for index in ba_concept_indices:
    ba_concepts.append(concepts[index])
    ba_fmri_data.append(data_c[index])
    ba_bert.append(concepts_bert[index])
    ba_glove.append(concepts_glove[index])

ba_fmri = np.array(ba_fmri_data)
ba_bert = np.array(ba_bert)
ba_glove = np.array(ba_glove)

word_list = ['engineer', 'lawyer', 'soldier','nurse', 'dancer', 'housekeeper', 'loyal', 'honest', 'strong', 'maternal', 'attractive', 'tidy']
kmeans_glove = get_glove_embeddings(word_list)

inputs_3 = tokenizer(word_list, return_tensors="pt", padding=True)
outputs_3 = model(**inputs_3)
last_hidden_states_3 = outputs_3.last_hidden_state
kmeans_bert = last_hidden_states_3[:,1,:].detach().numpy()

male_bert = man_woman[0]
female_bert = man_woman[1]

male_bert = create_gender_vector(embedding=model, male=True)
female_bert = create_gender_vector(embedding=model, male=False)

male_glove = create_gender_vector(embedding='glove', male=True)
female_glove = create_gender_vector(embedding='glove', male=False)

male_fmri = np.array(fmri_exp2[208], dtype='float64')
female_fmri = np.array(fmri_exp2[380], dtype='float64')

for i, concept in enumerate(concepts_exp3):
  print(i, concept)

for i, concept in enumerate(concepts_exp2):
  print(i, concept)

"""## Bias Analysis

### Language Biases on Single-Word Concepts
"""

lower_bert, upper_bert, nv_bert = neutral_dist(male_bert, female_bert, concepts_bert, neutral_indices, bins=6, threshold = 0.1)

bert_biases = create_bias_dict(male_bert, female_bert, ba_bert, lower_bert, upper_bert, ba_concepts)
bert_biases

lower_glove, upper_glove, nv_glove = neutral_dist(male_glove, female_glove, concepts_glove, neutral_indices, bins=10, threshold=0.1)

glove_biases = create_bias_dict(male_glove, female_glove, ba_glove, lower_glove, upper_glove, ba_concepts)
glove_biases

lower_fmri, upper_fmri, nv_fmri = neutral_dist(male_fmri, female_fmri, data_c, neutral_indices, bins=6, threshold=0.1)

fmri_biases = create_bias_dict(male_fmri, female_fmri, ba_fmri, lower_fmri, upper_fmri, ba_concepts)
fmri_biases

plot_top_biases(bert_biases, 'BERT')

plot_top_biases(glove_biases, 'GloVe')

plot_top_biases(fmri_biases, 'FMRI')

bb = list(wd['Score'] for wd in bert_biases.values())
gb = list(wd['Score'] for wd in glove_biases.values())
fb = list(wd['Score'] for wd in fmri_biases.values())

plt.figure(figsize=(10,6))
plt.plot(ba_concepts, bb, marker='o', label='Bert Biases')
plt.plot(ba_concepts, gb, marker='o', label='GloVe Biases')
plt.plot(ba_concepts, fb, marker='o', label='Brain Biases')
plt.plot(ba_concepts, np.zeros(len(ba_concepts)), linestyle='--')
plt.legend()
plt.xticks(rotation=75)
plt.ylabel('Bias')
plt.title('Bias Score for Different Word Embeddings')
plt.show()

"""### Fixed Clustering Analysis"""

run_kmeans_analysis(male_glove, female_glove, nv_glove, ba_glove, ba_concepts, reduction=None, embedding='Glove', to_predict=kmeans_glove, words_to_predict=word_list, show_names=True)

run_kmeans_analysis(male_bert, female_bert, nv_bert, ba_bert, ba_concepts, reduction=None, embedding='BERT', to_predict=kmeans_bert, words_to_predict=word_list, show_names=True)

run_kmeans_analysis(male_fmri, female_fmri, nv_fmri, ba_fmri, ba_concepts, reduction=None, embedding='FMRI', show_names=True)

"""### Random Clustering Analysis"""

def kmeans_cv(vectors):
    proportions = []
    n_list = [5, 8, 10, 15, 20, 25, 30]
    for n in n_list:
      sims = []
      for i in tqdm(range(10000)):
          kmeans = KMeans(n_clusters=n, init='random', n_init='auto').fit(vectors)
          labels = kmeans.labels_
          centroids = kmeans.cluster_centers_
          outcome = 1 if labels[66] == labels[67] else 0
          sims.append(outcome)
      print(f'Proportion of Runs Putting Male & Female in Same Cluster for {n} Clusters: {round(np.mean(sims), 5)*100}%')
      proportions.append(round(np.mean(sims), 5)*100)
    return proportions

ba_bert_added = np.append(ba_bert, np.reshape(male_bert, (1, 768)), axis=0)
ba_bert_added = np.append(ba_bert_added, np.reshape(female_bert, (1, 768)), axis=0)
ba_glove_added = np.append(ba_glove, np.reshape(male_glove, (1, 300)), axis=0)
ba_glove_added = np.append(ba_glove_added, np.reshape(female_glove, (1, 300)), axis=0)
ba_concepts_added = ba_concepts.copy()
ba_concepts_added.append('Male')
ba_concepts_added.append('Female')

glove_mean_prop = kmeans_cv(ba_glove_added)

bert_mean_prop = kmeans_cv(ba_bert_added)

run_random_kmeans(30, ba_glove_added, ba_concepts_added, kmeans_glove, word_list, True)

run_random_kmeans(30, ba_bert_added, ba_concepts_added, kmeans_bert, word_list, True)

n_its = [5, 8, 10, 15, 20, 25, 30]

plt.plot(n_its, bert_mean_prop, marker='o', label='Bert')
plt.plot(n_its, glove_mean_prop, marker='o', label='GloVe')
plt.legend()
plt.ylabel('%')
plt.xlabel('Number of Clusters')
plt.title('Proportion of Runs Clustering Male & Vectors Together - Mean Vectors')
plt.show()

mf = get_glove_embeddings(['male', 'female'])
male_glove_single = mf[0]
female_glove_single = mf[1]
ba_glove_added_single = np.append(ba_glove, np.reshape(male_glove_single, (1, 300)), axis=0)
ba_glove_added_single = np.append(ba_glove_added_single, np.reshape(female_glove_single, (1, 300)), axis=0)

male_bert_single = man_woman[0]
female_bert_single = man_woman[1]
ba_bert_added_single = np.append(ba_bert, np.reshape(male_bert_single, (1, 768)), axis=0)
ba_bert_added_single = np.append(ba_bert_added_single, np.reshape(female_bert_single, (1, 768)), axis=0)

glove_single_prop = kmeans_cv(ba_glove_added_single)
bert_single_prop = kmeans_cv(ba_bert_added_single)

plt.plot(n_its, bert_single_prop, marker='o', label='Bert')
plt.plot(n_its, glove_single_prop, marker='o', label='GloVe')
plt.legend()
plt.ylabel('%')
plt.xlabel('Number of Clusters')
plt.title('Proportion of Runs Clustering Male & Vectors Together - Mean Vectors')
plt.show()

"""### Re-run both analyses with BERT & fMRI PCA"""

concepts_bert_added = np.append(concepts_bert, np.reshape(male_bert, (1, 768)), axis=0)
concepts_bert_added = np.append(concepts_bert_added, np.reshape(female_bert, (1, 768)), axis=0)

concepts_bert_added = np.append(concepts_bert_added, kmeans_bert, axis=0)

fmri_added = np.append(data_c, np.reshape(male_fmri, (1, data_c.shape[1])), axis=0)
fmri_added = np.append(fmri_added, np.reshape(female_fmri, (1, data_c.shape[1])), axis=0)

n_components_bert = pca_cumulative_var("Bert Vectors ", concepts_bert_added, 0.85)
pca = PCA(n_components=n_components_bert, svd_solver = 'full')
pca.fit(concepts_bert_added)
bert_pca = pca.transform(concepts_bert_added)

n_components_fmri = pca_cumulative_var("fMRI Data ", fmri_added, 0.85)
pca = PCA(n_components=n_components_fmri, svd_solver = 'full')
pca.fit(fmri_added)
fmri_pca = pca.transform(fmri_added)

ba_bert_pca = []
ba_fmri_pca = []
for index in ba_concept_indices:
  ba_bert_pca.append(bert_pca[index])
  ba_fmri_pca.append(fmri_pca[index])
ba_fmri_pca = np.array(ba_fmri_pca)
ba_bert_pca = np.array(ba_bert_pca)

male_bert_pca = bert_pca[180]
female_bert_pca = bert_pca[181]
test_bert_pca = bert_pca[182:]

male_fmri_pca = fmri_pca[180]
female_fmri_pca = fmri_pca[181]

lower_bert, upper_bert, nv_bert = neutral_dist(male_bert_pca, female_bert_pca, bert_pca, neutral_indices, bins=6, threshold = 0.1)

bert_biases = create_bias_dict(male_bert_pca, female_bert_pca, ba_bert_pca, lower_bert, upper_bert, ba_concepts)
bert_biases

plot_top_biases(bert_biases, 'BERT')

lower_fmri, upper_fmri, nv_fmri = neutral_dist(male_fmri_pca, female_fmri_pca, fmri_pca, neutral_indices, bins=6, threshold=0.1)

fmri_biases = create_bias_dict(male_fmri_pca, female_fmri_pca, ba_fmri_pca, lower_fmri, upper_fmri, ba_concepts)
fmri_biases

plot_top_biases(fmri_biases, 'FMRI')

bb = list(wd['Score'] for wd in bert_biases.values())
gb = list(wd['Score'] for wd in glove_biases.values())
fb = list(wd['Score'] for wd in fmri_biases.values())

plt.figure(figsize=(10,6))
plt.plot(ba_concepts, bb, marker='o', label='Bert Biases')
plt.plot(ba_concepts, gb, marker='o', label='GloVe Biases')
plt.plot(ba_concepts, fb, marker='o', label='Brain Biases')
plt.plot(ba_concepts, np.zeros(len(ba_concepts)), linestyle='--')
plt.legend()
plt.xticks(rotation=75)
plt.ylabel('Bias')
plt.title('Bias Score for Different Word Embeddings')
plt.show()

run_kmeans_analysis(male_bert_pca, female_bert_pca, nv_bert, ba_bert_pca, ba_concepts, reduction=None, embedding='BERT', to_predict=test_bert_pca, words_to_predict=word_list, show_names=True)

run_kmeans_analysis(male_fmri_pca, female_fmri_pca, nv_fmri, ba_fmri_pca, ba_concepts, reduction=None, embedding='FMRI', show_names=True)

bert_pca_added = np.append(ba_bert_pca, np.reshape(bert_pca[180], (1, bert_pca.shape[1])), axis=0)
bert_pca_added = np.append(bert_pca_added, np.reshape(bert_pca[181], (1, bert_pca.shape[1])), axis=0)

run_random_kmeans(30, bert_pca_added, ba_concepts_added, test_bert_pca, word_list, True)

"""## Debiasing Word Embeddings

### Functions
"""

bert_male = ['war', 'money', 'king', 'job', 'gun', 'great', 'fight', 'election', 'big', 'beer']
bert_female = ['protection', 'lady', 'kindness', 'elegance']
glove_male = ['war', 'liar', 'great', 'fight', 'engine', 'driver', 'bar']
glove_female = ['sexy', 'sew', 'marriage', 'lady', 'hair', 'emotionally', 'elegance', 'dressing', 'dance', 'clothes', 'charming']
fmri_male = ['personality', 'invisible', 'fight', 'engine', 'emotionally', 'dressing', 'doctor', 'charming', 'business']
fmri_female = ['sexy', 'poor', 'lady', 'dangerous', 'dance', 'code', 'clothes']
pca_bert_male = ['war', 'money', 'king', 'job', 'gun', 'gold', 'fight', 'crazy', 'body', 'big', 'beer', 'bar', 'ball']
pca_bert_female = ['poor', 'lady', 'kindness', 'engine', 'elegance', 'clothes', 'charity', 'carefully']
fmri_pca_male = ['weak', 'personality', 'invisible', 'fight', 'emotionally', 'dressing', 'doctor', 'charming', 'business']
fmri_pca_female =['sexy', 'poor', 'lady', 'dangerous', 'code', 'clothes']

tokenizer = AutoTokenizer.from_pretrained("bert-base-uncased")
model = BertModel.from_pretrained("bert-base-uncased")

def bert_embedding (words_lst):

  inputs = tokenizer(list(words_lst), return_tensors="pt", padding=True)
  outputs = model(**inputs)

  last_hidden_states = outputs.last_hidden_state
  vectors_bert = last_hidden_states[:,1,:].detach().numpy()

  return vectors_bert

from scipy.linalg import svd

def identify_gender_subspace(vectors, k= 1): #identifies a direction or subspace that captures the gender bias in the word embeddings
  means= []

  for i in range (0, vectors.shape[0], 2):
    means.append((vectors[i]+ vectors[i+1])/2)

  C = np.zeros((vectors.shape[1], vectors.shape[1]))

  for i in range (0, vectors.shape[0], 2):
    mean_index = int(i/2)
    C += np.outer(vectors[i]- means[mean_index], vectors[i]- means[mean_index])/2
    C += np.outer(vectors[i+1]- means[mean_index], vectors[i+1]- means[mean_index])/2

  _, _, V = svd(C)
  subspace = V[:k]

  return subspace

def neutralize_debias(definitional_pairs,neutralize_set):
  new_embedding= []
  subspace = identify_gender_subspace(definitional_pairs)

  for word in neutralize_set: #gender neutral words will be 0 in the gender subspace
    projection = np.dot(subspace.T, np.dot(subspace, word))
    word = (word- projection)/ np.linalg.norm(word- projection)
    new_embedding.append(word)

  return new_embedding

def equalize_debias (definitional_pairs, equality_set):
  new_embedding= []
  subspace = identify_gender_subspace(definitional_pairs)

  mean = np.mean(equality_set, axis= 0)
  mean_projection = np.dot(subspace.T, np.dot(subspace, mean))
  v = mean- mean_projection
  for word in equality_set: #neutral words will be equidistant to all words in each equality set

        word_calc1 = np.sqrt(1-((np.linalg.norm(v)/v.shape[0])**2))
        word_projection = np.dot(subspace.T, np.dot(subspace, word))
        word_calc2= (word_projection- mean_projection)/ (np.linalg.norm(word_projection- mean_projection))
        new_embedding.append(word_calc1*word_calc2 + v)

  return new_embedding

import cvxpy as cp

def soft_debias(all_words, reg, N, B):
  new_embeddings = []
  n= all_words.shape[0]
  T = cp.Variable((n, n))

  print(T.shape)
  print(all_words.shape)

  objective = cp.Minimize((cp.norm(((T @ all_words).T @ (T @ all_words) - all_words.T @ all_words), 'fro')**2)+ reg*(cp.norm(((T @ N).T @ (T @ B)), 'fro')**2))
  problem = cp.Problem(objective)
  problem.solve()

  T_optimal = T.value
  print(T_optimal)

  for word in all_words:
    word= (word.T)*T_optimal
    new_embeddings.append(word)

  return new_embeddings

def analogy_vector(w1: str, w2: str, w3: str, e: dict) -> np.ndarray: # note that the function takes the word embedding dictionary as input.
  return e[w2]- e[w1] + e[w3]

def analogy(w1: str, w2: str, w3: str, e: dict, k=5):
  y= analogy_vector(w1, w2, w3, e)
  neighbors= {}

  for word in e:
     neighbors[word] = cosine_similarity(y, e[word])

  neighbors = dict(sorted(neighbors.items(), key=lambda item: item[1], reverse= True))
  top_k_keys = []
  for i, key in enumerate(neighbors.keys()):
    if key!= w3:
        top_k_keys.append(key)
    if i == k:
        break

  print (w1 + " is to " +w2 +" as " +w3 +" is to: ")
  return top_k_keys

def replace_embedding_after_debias (vectors_dict, words_to_change, new_embeddings):

  for key, value in zip(words_to_change, new_embeddings):
        vectors_dict[key] = value

  return vectors_dict

def set_embeddings (embeddings_dict, definitional_pairs, equalize_pairs, neutralize_words):
  definitional_embeddings = [embeddings_dict[key] for key in definitional_pairs if key in embeddings_dict]
  definitional_embeddings= np.array(definitional_embeddings)
  equalize_embeddings  = [embeddings_dict[key] for key in equalize_pairs if key in embeddings_dict]
  equalize_embeddings= np.array(equalize_embeddings)
  neutralize_embeddings = [embeddings_dict[key] for key in neutralize_words if key in embeddings_dict]
  neutralize_embeddings= np.array(neutralize_embeddings)

  return definitional_embeddings,equalize_embeddings, neutralize_embeddings

"""### Data"""

definitional_pairs = ["woman", "man", "girl", "boy", "she", "he", "mother", "father", "daughter", "son", "gal", "guy", "female", "male", "her",
                      "his", "herself", "himself", "mary", "john"]
equalize_pairs= ["monastery", "convent", "spokesman", "spokeswoman", "dad", "mom", "men", "women", "councilman", "councilwoman", "grandpa",
                 "grandma", "grandsons", "granddaughters", "testosterone", "estrogen", "uncle", "aunt", "wives", "husbands", "father", "mother",
                 "grandpa", "grandma", "he", "she", "boy", "girl", "boys", "girls", "brother", "sister", "brothers", "sisters", "businessman",
                 "businesswoman", "chairman", "chairwoman", "colt", "filly", "congressman", "congresswoman", "dad", "mom", "dads", "moms", "dudes",
                 "gals", "father", "mother", "fatherhood", "motherhood", "fathers", "mothers", "fella", "granny", "fraternity", "sorority",
                 "gelding", "mare", "gentleman", "lady", "gentlemen", "ladies", "grandfather", "grandmother", "grandson", "granddaughter",
                 "he", "she", "himself", "herself", "his", "her", "king", "queen", "kings", "queens", "male", "female", "males", "females",
                 "man", "woman", "men", "women", "nephew", "niece", "prince", "princess", "schoolboy", "schoolgirl", "son", "daughter", "sons",
                 "daughters"]
neutralize_words = [
    "tree","table","paper","wall","floor","door","window","lamp","computer","book","car","chair","plant","clock","shirt","hat","plate",
    "spoon","fork","mirror","cup","picture","painting","brush","knife","blanket","pillow","box","bowl","dog","cat","puppy", "kitten", "pen",
    "canvas", "paintbrush","person", "individual", "human", "being", "creature", "mortal",
     "figure", "body", "folk", "society", "mankind",
    "people", "humanity", "personage",
    "individuality", "soul",
    "individualism", "specimen", "identity", "selfhood", "existence", "life",
    "personality", "essence", "consciousness", "somesuch", "personhood",
    "somebody", "lifeform", "personification",
    "subject", "homosapien", "someone", "humanoid",
    "character","war", "money", "job", "gun", "great", "fight", "election", "big", "beer","protection", "kindness", "elegance",
    "liar", "engine", "driver", "bar", "sexy", "sew", "marriage", "hair", "emotionally", "dressing", "dance", "clothes", "charming",
    "invisible", "doctor", "business","poor","dangerous","code","gold", "crazy", "ball","charity", "carefully","weak"
]

all_words = definitional_pairs+equalize_pairs+neutralize_words
all_words = set(all_words)

"""### Bert"""

bert_vectors_definitional = bert_embedding(definitional_pairs)
bert_vectors_equalize = bert_embedding(equality_sets)
bert_vectors_neutralize = bert_embedding(neutralize_words)
bert_vectors_words_to_debias = bert_embedding(words_to_debias)

embeddings_equalize_debias= equalize_debias(bert_vectors_definitional,bert_vectors_equalize)
embeddings_neutralize_debias = neutralize_debias(bert_vectors_definitional,bert_vectors_neutralize)
all_words_neutralize= neutralize_debias(bert_vectors_definitional,bert_vectors_words_to_debias)
all_words_equalize= equalize_debias(bert_vectors_definitional,bert_vectors_words_to_debias)

"""Results - equalize debias"""

print(f'Before running debias:')
print(analogy("man","woman","king",equality_sets,bert_vectors_equalize ))
print(analogy("father","mother","grandpa",equality_sets,bert_vectors_equalize ))
print(analogy("she","he","girl",equality_sets,bert_vectors_equalize ))

print(f'After running debias:')
print(analogy("man","woman","king",equality_sets,embeddings_equalize_debias ))
print(analogy("father","mother","grandpa",equality_sets,embeddings_equalize_debias ))
print(analogy("she","he","girl",equality_sets,embeddings_equalize_debias ))

"""Results - neutralize debias"""

print(f'Before running debias:')
print(analogy("paper","pen","canvas",neutralize_words,bert_vectors_neutralize ))
print(analogy("dog","cat","puppy",neutralize_words,bert_vectors_neutralize ))

print(f'After running debias:')
print(analogy("paper","pen","canvas",neutralize_words,embeddings_neutralize_debias ))
print(analogy("dog","cat","puppy",neutralize_words,embeddings_neutralize_debias ))

"""Neutralize and Equalize on "words to debias"
"""

print(f'Before running debias:')
print(analogy("paper","pen","canvas",words_to_debias,bert_vectors_words_to_debias ))
print(analogy("dog","cat","puppy",words_to_debias,bert_vectors_words_to_debias ))

print(f'After running neutralize debias:')
print(analogy("paper","pen","canvas",words_to_debias,all_words_neutralize ))
print(analogy("dog","cat","puppy",words_to_debias,all_words_neutralize ))

print(f'After running equalize debias:')
print(analogy("paper","pen","canvas",words_to_debias,all_words_equalize ))
print(analogy("dog","cat","puppy",words_to_debias,all_words_equalize ))

"""### GloVe"""

glove_vectors_definitional = get_glove_embeddings(definitional_pairs)
glove_vectors_equalize = get_glove_embeddings(equality_sets)
glove_vectors_neutralize = get_glove_embeddings(neutralize_words)
glove_vectors_words_to_debias = get_glove_embeddings(words_to_debias)

embeddings_equalize_debias_glove= equalize_debias(glove_vectors_definitional,glove_vectors_equalize)
embeddings_neutralize_debias_glove = neutralize_debias(glove_vectors_definitional,glove_vectors_neutralize)
all_words_neutralize_glove= neutralize_debias(glove_vectors_definitional,glove_vectors_words_to_debias)
all_words_equalize_glove= equalize_debias(glove_vectors_definitional,glove_vectors_words_to_debias)

"""Results - equalize debias"""

print(f'Before running debias:')
print(analogy("man","woman","king",equality_sets,glove_vectors_equalize ))
print(analogy("father","mother","grandpa",equality_sets,glove_vectors_equalize ))
print(analogy("she","he","girl",equality_sets,glove_vectors_equalize ))

print(f'After running debias:')
print(analogy("man","woman","king",equality_sets,embeddings_equalize_debias_glove ))
print(analogy("father","mother","grandpa",equality_sets,embeddings_equalize_debias_glove ))
print(analogy("she","he","girl",equality_sets,embeddings_equalize_debias_glove ))

"""Results - neutralize debias"""

print(f'Before running debias:')
print(analogy("paper","pen","canvas",neutralize_words,glove_vectors_neutralize ))
print(analogy("dog","cat","puppy",neutralize_words,glove_vectors_neutralize ))

print(f'After running debias:')
print(analogy("paper","pen","canvas",neutralize_words,embeddings_neutralize_debias_glove ))
print(analogy("dog","cat","puppy",neutralize_words,embeddings_neutralize_debias_glove ))

"""Neutralize and Equalize on "words to debias"
"""

print(f'Before running debias:')
print(analogy("paper","pen","canvas",words_to_debias,glove_vectors_words_to_debias ))
print(analogy("dog","cat","puppy",words_to_debias,glove_vectors_words_to_debias ))

print(f'After running neutralize debias:')
print(analogy("paper","pen","canvas",words_to_debias,all_words_neutralize_glove ))
print(analogy("dog","cat","puppy",words_to_debias,all_words_neutralize_glove ))

print(f'After running equalize debias:')
print(analogy("paper","pen","canvas",words_to_debias,all_words_equalize_glove ))
print(analogy("dog","cat","puppy",words_to_debias,all_words_equalize_glove ))

"""### Debias 200 words (glove)

Analogy test
"""

glove_vectors_debias = get_glove_embeddings(all_words)
glove_vectors_dict = {key: value for key, value in zip(all_words, glove_vectors_debias)}

print(f'Before running debias:')
print(analogy("man","woman","king",glove_vectors_dict))
print(analogy("father","mother","grandpa",glove_vectors_dict))
print(analogy("she","he","girl",glove_vectors_dict ))

print(analogy("paper","pen","canvas",glove_vectors_dict))
print(analogy("dog","cat","puppy",glove_vectors_dict))
print(analogy("man","code","woman",glove_vectors_dict))
print(analogy("woman","doctor","man",glove_vectors_dict))

definitional_embeddings,equalize_embeddings, neutralize_embeddings = set_embeddings(glove_vectors_dict)

embeddings_neutralize_debias_glove = neutralize_debias(definitional_embeddings,neutralize_embeddings)
glove_vectors_dict = replace_embedding_after_debias(glove_vectors_dict, neutralize_words, embeddings_neutralize_debias_glove)
embeddings_equalize_debias_glove= equalize_debias(definitional_embeddings,equalize_embeddings)
glove_vectors_dict = replace_embedding_after_debias(glove_vectors_dict, equalize_pairs, embeddings_equalize_debias_glove)

print(f'After running debias:')
print(analogy("man","woman","king",glove_vectors_dict))
print(analogy("father","mother","grandpa",glove_vectors_dict))
print(analogy("she","he","girl",glove_vectors_dict ))

print(analogy("paper","pen","canvas",glove_vectors_dict))
print(analogy("dog","cat","puppy",glove_vectors_dict))
print(analogy("man","code","woman",glove_vectors_dict))
print(analogy("woman","doctor","man",glove_vectors_dict))

"""### Debias all words -glove

Analogy Test
"""

print(f'Before running debias:')
print(analogy("man","woman","king",all_embeddings))
print(analogy("father","mother","grandpa",all_embeddings))
print(analogy("she","he","girl",all_embeddings ))

print(analogy("paper","pen","canvas",all_embeddings))
print(analogy("dog","cat","puppy",all_embeddings))
print(analogy("man","code","woman",all_embeddings))
print(analogy("woman","doctor","man",all_embeddings))

definitional_embeddings,equalize_embeddings, neutralize_embeddings = set_embeddings(all_embeddings,  definitional_pairs, equalize_pairs, neutralize_words)

embeddings_neutralize_debias_glove = neutralize_debias(definitional_embeddings,neutralize_embeddings)
glove_vectors_dict_debias = replace_embedding_after_debias(all_embeddings, neutralize_words, embeddings_neutralize_debias_glove)
embeddings_equalize_debias_glove= equalize_debias(definitional_embeddings,equalize_embeddings)
glove_vectors_dict_debias = replace_embedding_after_debias(glove_vectors_dict_debias, equalize_pairs, embeddings_equalize_debias_glove)

print(f'After running debias:')
print(analogy("man","woman","king",glove_vectors_dict_debias))
print(analogy("father","mother","grandpa",glove_vectors_dict_debias))
print(analogy("she","he","girl",glove_vectors_dict_debias ))

print(analogy("paper","pen","canvas",glove_vectors_dict_debias))
print(analogy("dog","cat","puppy",glove_vectors_dict_debias))
print(analogy("man","code","woman",glove_vectors_dict_debias))
print(analogy("woman","doctor","man",glove_vectors_dict_debias))

"""Learn Decoder"""

vectors_after_debias = [glove_vectors_dict_debias[key] for key in concepts if key in glove_vectors_dict_debias]
vectors_after_debias= np.array (vectors_after_debias)

all_ranks_debias, avg_ranks_debias = train_decoder(data,vectors_after_debias, concepts)

plot_fold_avg_acc(18,avg_ranks_debias)

successful_debias, failed_debias = successful_failed_concepts(concepts, all_ranks_debias)

plot_concepts(successful_debias, "successful concepts ", "after debias", "- glove embedding")

plot_concepts(failed_debias, "failed concepts ", "after debias", "- glove embedding")

"""Bias Words"""

# extracting relevant features for analysis. Note that indices89 & 90 (lady and king) are non gender-neutral
neutral_indices = [3, 4, 5, 6, 8, 9, 12, 13, 14, 17, 18, 21, 22, 23, 25, 27, 31, 33, 35, 37, 39, 43, 42, 44, 45, 46, 47, 48, 51, 52, 53, 55, 58, 60, 65, 66, 67, 70, 71, 72, 73, 78, 79, 81, 83, 84, 87, 91, 92, 93, 94, 95, 97, 98, 100, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 115, 116, 118, 119, 120, 121, 126, 127, 128, 129, 131, 132, 133, 135, 136, 139, 140, 141, 42, 143, 144, 145, 147, 148, 149, 150, 151, 152, 156, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 172, 174, 176, 177, 178, 179]
ba_concept_indices = [0, 1, 2, 7, 10, 11, 15, 16, 19, 20, 24, 26, 28, 29, 30, 32, 34, 36, 38, 40, 41, 49, 50, 54, 56, 57, 59, 61, 62, 63, 64, 68, 69, 74, 75, 76, 77, 80, 82, 85, 86, 88, 89, 90, 96, 99, 101, 104, 114, 117, 122, 123, 124, 125, 130, 134, 137, 138, 146, 153, 154, 155, 157, 171, 173, 175]
ba_concepts = []
ba_glove = []
for index in ba_concept_indices:
    ba_concepts.append(concepts[index])
    ba_glove.append(vectors_after_debias[index])

ba_glove = np.array(ba_glove)

male_glove = create_gender_vector(male=True)
female_glove = create_gender_vector(male=False)

lower_glove, upper_glove, nv_glove = neutral_dist(male_glove, female_glove, vectors_after_debias, neutral_indices, bins=10, threshold=0.1)

glove_biases = create_bias_dict(male_glove, female_glove, ba_glove, lower_glove, upper_glove, ba_concepts)
glove_biases

plot_top_biases(glove_biases, 'GloVe')

"""### Debias all words - Bert"""

words_list_bert = list(all_words) + list(concepts)
words_list_bert= set(words_list_bert)
words_list_bert= list(words_list_bert)
all_embeddings_bert= bert_embedding(words_list_bert)

bert_vectors_dict = {key: value for key, value in zip(words_list_bert, all_embeddings_bert)}

definitional_embeddings_bert,equalize_embeddings_bert, neutralize_embeddings_bert = set_embeddings(bert_vectors_dict, definitional_pairs, equalize_pairs, neutralize_words)

embeddings_neutralize_debias_bert = neutralize_debias(definitional_embeddings_bert,neutralize_embeddings_bert)
bert_vectors_dict_debias = replace_embedding_after_debias(bert_vectors_dict, neutralize_words, embeddings_neutralize_debias_bert)
embeddings_equalize_debias_bert= equalize_debias(definitional_embeddings_bert,equalize_embeddings_bert)
bert_vectors_dict_debias = replace_embedding_after_debias(bert_vectors_dict_debias, equalize_pairs, embeddings_equalize_debias_bert)

"""Learn Decoder"""

bert_vectors_after_debias = [bert_vectors_dict_debias[key] for key in concepts if key in bert_vectors_dict_debias]
bert_vectors_after_debias= np.array (bert_vectors_after_debias)

all_ranks_debias_bert, avg_ranks_debias_bert = train_decoder(data,bert_vectors_after_debias, concepts)

plot_fold_avg_acc(18,avg_ranks_debias_bert)

successful_debias_bert, failed_debias_bert = successful_failed_concepts(concepts, all_ranks_debias_bert)

plot_concepts(successful_debias_bert, "successful concepts ", "after debias", "- bert embedding")

plot_concepts(failed_debias_bert, "failed concepts ", "after debias", "- bert embedding")

"""Bias Words"""

# extracting relevant features for analysis. Note that indices89 & 90 (lady and king) are non gender-neutral
neutral_indices = [3, 4, 5, 6, 8, 9, 12, 13, 14, 17, 18, 21, 22, 23, 25, 27, 31, 33, 35, 37, 39, 43, 42, 44, 45, 46, 47, 48, 51, 52, 53, 55, 58, 60, 65, 66, 67, 70, 71, 72, 73, 78, 79, 81, 83, 84, 87, 91, 92, 93, 94, 95, 97, 98, 100, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 115, 116, 118, 119, 120, 121, 126, 127, 128, 129, 131, 132, 133, 135, 136, 139, 140, 141, 42, 143, 144, 145, 147, 148, 149, 150, 151, 152, 156, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 172, 174, 176, 177, 178, 179]
ba_concept_indices = [0, 1, 2, 7, 10, 11, 15, 16, 19, 20, 24, 26, 28, 29, 30, 32, 34, 36, 38, 40, 41, 49, 50, 54, 56, 57, 59, 61, 62, 63, 64, 68, 69, 74, 75, 76, 77, 80, 82, 85, 86, 88, 89, 90, 96, 99, 101, 104, 114, 117, 122, 123, 124, 125, 130, 134, 137, 138, 146, 153, 154, 155, 157, 171, 173, 175]
ba_concepts = []
ba_bert = []
for index in ba_concept_indices:
    ba_concepts.append(concepts[index])
    ba_bert.append(bert_vectors_after_debias[index])

ba_bert = np.array(ba_bert)

male_bert = create_gender_vector("bert", male=True)
female_bert= create_gender_vector("bert" ,male=False)

lower_bert, upper_bert, nv_bert = neutral_dist(male_bert, female_bert, bert_vectors_after_debias, neutral_indices, bins=10, threshold=0.1)

bert_biases = create_bias_dict(male_bert, female_bert, ba_bert, lower_bert, upper_bert, ba_concepts)
bert_biases

plot_top_biases(bert_biases, 'Bert')

"""### Debias fmri"""

#neutralize set
neutral_indices = [3, 4, 5, 6, 8, 9, 12, 13, 14, 17, 18, 21, 22, 23, 25, 27, 31, 33, 35, 37, 39, 43, 42, 44, 45, 46, 47, 48, 51, 52, 53, 55, 58, 60, 65, 66, 67, 70, 71, 72, 73, 78, 79, 81, 83, 84, 87, 91, 92, 93, 94, 95, 97, 98, 100, 102, 103, 105, 106, 107, 108, 109, 110, 111, 112, 113, 115, 116, 118, 119, 120, 121, 126, 127, 128, 129, 131, 132, 133, 135, 136, 139, 140, 141, 42, 143, 144, 145, 147, 148, 149, 150, 151, 152, 156, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 172, 174, 176, 177, 178, 179]

neutralize_fmri = []
neutralize_words_fmri= []
for index in neutral_indices:
    neutralize_fmri.append(data_c[index])
    neutralize_words_fmri.append(concepts[index])

neutralize_fmri = np.array(neutralize_fmri)

#equalize set
equalize_fmri = []
equalize_pairs_fmri= ["lady", "king", "boy", "girl"]
equalize_fmri.append(data_c[89]) #lady
equalize_fmri.append(data_c[90]) #king
equalize_fmri.append(fmri_exp2[209]) #boy
equalize_fmri.append(fmri_exp2[156]) #girl


#definitional set
definitional_fmri= []
definitional_fmri.append(fmri_exp2[208]) #male
definitional_fmri.append(fmri_exp2[380]) #female
definitional_fmri.append(fmri_exp2[209]) #boy
definitional_fmri.append(fmri_exp2[156]) #girl


neutralize_fmri = np.array(neutralize_fmri)
equalize_fmri = np.array(equalize_fmri)
definitional_fmri = np.array(definitional_fmri)

extended_words = ["boy", "girl", "male", "female"]
words_list_fmri = concepts
words_list_fmri= np.append(concepts,extended_words )

extended_embeddings = [fmri_exp2[209], fmri_exp2[156], fmri_exp2[208], fmri_exp2[380]]
all_embeddings_fmri =np.append(data_c,extended_embeddings )

fmri_vectors_dict = {key: value for key, value in zip(words_list_fmri, all_embeddings_fmri)}

embeddings_neutralize_debias_fmri = neutralize_debias(definitional_fmri,neutralize_fmri)
fmri_vectors_dict_debias = replace_embedding_after_debias(fmri_vectors_dict, neutralize_words_fmri, embeddings_neutralize_debias_fmri)
embeddings_equalize_debias_fmri= equalize_debias(definitional_fmri,equalize_fmri)
fmri_vectors_dict_debias = replace_embedding_after_debias(fmri_vectors_dict_debias, equalize_pairs_fmri , embeddings_neutralize_debias_fmri)

"""### Summary and Results

Debiasing embeddings involves reducing or eliminating gender bias in word representations to reduce stereotypes, promote fairness, and address gender inequalities in natural language processing applications.

We attempted to recreate the algorithms described in the article "Man is to Computer Programmer as Woman is to Homemaker":

The first step, called "Identify gender subspace," is about finding a direction or pattern in the word embeddings that represents gender bias. It helps us understand how gender-related words are positioned in the embedding space.

The second step is "Neutralize and Equalize":
Neutralize ensures that words considered gender-neutral have zero influence in the gender subspace. It removes any bias associated with those words.
Equalize, on the other hand, tries to make sets of words that are outside the gender subspace to be equally distant from each other. This means that any gender-neutral word will have the same similarity or distance to all words in those sets. However, equalizing can remove certain distinctions that are useful in some applications.

We successfully recreated the algorithms described in the article. We created a neutralized set and an equalized set, similar to the sets used in the article, by selecting words from a large GloVe corpus. After applying the debiasing techniques to these sets and modifying the embeddings of the respective words, we ran "train decoder" on the same set of concepts and fMRI data as in previous experiments.
The average scores obtained from each fold were very close to the original results from previous experiments (HW3). The top three successful concepts remained identical, while some of the remaining top 15 concepts had similar words but with slightly different rankings. This indicates that the contextual relationships between words were preserved after debiasing.
When evaluating for bias using the same bias test as before, the results were remarkable. Only three words exhibited bias: "king" displayed bias towards males, "lady" showed bias towards females, and "hair" exhibited a very low bias towards females.

Overall, the results demonstrated the effectiveness of the debiasing algorithms in reducing biases in word embeddings while preserving contextual relationships between words. The results indicated significant improvements in mitigating gender bias and promoting fairness in language processing tasks.

*gpt - GloVe vs. Bert*

The performance of different algorithms on debiasing gender in word embeddings can vary based on their underlying architectures and training methodologies. In this case, running a debiasing algorithm on GloVe embeddings resulted in amazing results, while the same algorithm performed poorly on BERT embeddings. Let's explore some possible reasons for this difference:

Architecture Differences: GloVe and BERT have different underlying architectures. GloVe (Global Vectors for Word Representation) is a count-based model that learns word vectors based on co-occurrence statistics in a large corpus of text. On the other hand, BERT (Bidirectional Encoder Representations from Transformers) is a transformer-based model that learns contextualized word representations by training on a large amount of unlabeled text. These architectural differences can impact how gender biases are encoded and affect the performance of debiasing algorithms.

Contextual Embeddings: BERT provides contextualized word embeddings, meaning the embedding of a word can vary depending on its context within a sentence. This contextual nature of BERT embeddings can make it more challenging to detect and remove gender bias accurately. The debiasing algorithm might struggle to identify and neutralize gender associations due to the complex interactions between words and their contexts.

Bias Amplification: It's possible that the debiasing algorithm applied to BERT embeddings inadvertently amplified biases instead of mitigating them. If the algorithm mistakenly assigned higher importance to certain gender-related features during the debiasing process, it could have unintentionally exacerbated the bias present in the embeddings.

Dataset and Training Methodology: The performance of debiasing algorithms can be influenced by the dataset used for training and evaluation. It's possible that the algorithm was trained and evaluated on a dataset that better aligned with the characteristics of GloVe embeddings, leading to superior results for that specific type of embedding. The choice of debiasing algorithm and the specific techniques employed could also contribute to the disparity in performance.

Evaluation Metrics: The evaluation metrics used to assess the performance of debiasing algorithms might not have been appropriate or comprehensive enough to capture the nuances of gender bias in BERT embeddings. Different evaluation methodologies can yield contrasting results, making it essential to choose metrics that adequately capture the desired aspects of debiasing.

In summary, the differences in performance between debiasing gender algorithms applied to GloVe and BERT embeddings can be attributed to various factors, such as the architectural dissimilarities, contextual nature of BERT embeddings, bias amplification, dataset characteristics, training methodologies, and evaluation metrics. Understanding these factors is crucial for improving the effectiveness of debiasing algorithms and achieving more accurate and robust results in addressing gender bias in word embeddings.

# Export to PDF

Run the following cell to download the notebook as a nicely formatted pdf file.
"""

# Add to a new cell at the end of the notebook and run the follow code,
# which will save the notebook as pdf in your google drive (allow the permissions) and download it automatically.

!wget -nc https://raw.githubusercontent.com/brpy/colab-pdf/master/colab_pdf.py

from colab_pdf import colab_pdf

# If you saved the notebook in the default location in your Google Drive,
# and didn't change the name of the file, the code should work as is.
# If not, adapt accordingly.

colab_pdf(file_name='Copy of Pset_3.ipynb', notebookpath="/content/drive/MyDrive/Colab Notebooks/")

# Commented out IPython magic to ensure Python compatibility.
# %%shell
# jupyter nbconvert --to html /content/Copy_of_Pset_3.ipynb